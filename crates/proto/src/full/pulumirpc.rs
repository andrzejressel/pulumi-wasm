// This file is @generated by prost-build.
/// PluginInfo is meta-information about a plugin that is used by the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginInfo {
    /// the semver for this plugin.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
/// PluginDependency is information about a plugin that a program may depend upon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginDependency {
    /// the name of the plugin.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the kind of plugin (e.g., language, etc).
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// the semver for this plugin.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// the URL of a server that can be used to download this plugin, if needed.
    #[prost(string, tag = "4")]
    pub server: ::prost::alloc::string::String,
    /// a map of the checksums for the plugin, will be empty from old language runtimes. The keys should match
    /// the os and architecture names used in pulumi releases, e.g. "darwin-amd64", "windows-arm64".
    #[prost(map = "string, bytes", tag = "5")]
    pub checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
/// PluginAttach is used to attach an already running plugin to the engine.
///
/// Normally the engine starts the plugin process itself and passes the engine address as the first argumnent.
/// But when debugging it can be useful to have an already running provider that the engine instead attaches
/// to, this message is used so the provider can still be passed the engine address to communicate with.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginAttach {
    /// the grpc address for the engine
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageParameterization {
    /// the parameterized package name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the parameterized package version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the parameter value for the parameterized package.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// PackageDependency is information about a package that a program may depend upon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageDependency {
    /// the name of the plugin.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the kind of plugin (e.g., language, etc).
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// the semver for this plugin.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// the URL of a server that can be used to download this plugin, if needed.
    #[prost(string, tag = "4")]
    pub server: ::prost::alloc::string::String,
    /// a map of the checksums for the plugin, will be empty from old language runtimes. The keys should match
    /// the os and architecture names used in pulumi releases, e.g. "darwin-amd64", "windows-arm64".
    #[prost(map = "string, bytes", tag = "5")]
    pub checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// The optional parameterization for this package.
    #[prost(message, optional, tag = "6")]
    pub parameterization: ::core::option::Option<PackageParameterization>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogRequest {
    /// the logging level of this message.
    #[prost(enumeration = "LogSeverity", tag = "1")]
    pub severity: i32,
    /// the contents of the logged message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// the (optional) resource urn this log is associated with.
    #[prost(string, tag = "3")]
    pub urn: ::prost::alloc::string::String,
    /// the (optional) stream id that a stream of log messages can be associated with. This allows
    /// clients to not have to buffer a large set of log messages that they all want to be
    /// conceptually connected.  Instead the messages can be sent as chunks (with the same stream id)
    /// and the end display can show the messages as they arrive, while still stitching them together
    /// into one total log message.
    ///
    /// 0/not-given means: do not associate with any stream.
    #[prost(int32, tag = "4")]
    pub stream_id: i32,
    /// Optional value indicating whether this is a status message.
    #[prost(bool, tag = "5")]
    pub ephemeral: bool,
}
/// empty.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRootResourceRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRootResourceResponse {
    /// the URN of the root resource, or the empty string if one was not set.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRootResourceRequest {
    /// the URN of the root resource, or the empty string.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
}
/// empty.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetRootResourceResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartDebuggingRequest {
    /// the debug configuration parameters.  These are meant to be in the right format for the DAP protocol to consume.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<::prost_types::Struct>,
    /// the string to display to the user with instructions on how to connect to the debugger.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// LogSeverity is the severity level of a log message.  Errors are fatal; all others are informational.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogSeverity {
    /// a debug-level message not displayed to end-users (the default).
    Debug = 0,
    /// an informational message printed to output during resource operations.
    Info = 1,
    /// a warning to indicate that something went wrong.
    Warning = 2,
    /// a fatal error indicating that the tool should stop processing subsequent resource operations.
    Error = 3,
}
impl LogSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Debug => "DEBUG",
            Self::Info => "INFO",
            Self::Warning => "WARNING",
            Self::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEBUG" => Some(Self::Debug),
            "INFO" => Some(Self::Info),
            "WARNING" => Some(Self::Warning),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod engine_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Engine is an auxiliary service offered to language and resource provider plugins. Its main purpose today is
    /// to serve as a common logging endpoint, but it also serves as a state storage mechanism for language hosts
    /// that can't store their own global state.
    #[derive(Debug, Clone)]
    pub struct EngineClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EngineClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EngineClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EngineClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EngineClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Log logs a global message in the engine, including errors and warnings.
        pub async fn log(
            &mut self,
            request: impl tonic::IntoRequest<super::LogRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Engine/Log");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "Log"));
            self.inner.unary(req, path, codec).await
        }
        /// GetRootResource gets the URN of the root resource, the resource that should be the root of all
        /// otherwise-unparented resources.
        pub async fn get_root_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRootResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRootResourceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Engine/GetRootResource");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "GetRootResource"));
            self.inner.unary(req, path, codec).await
        }
        /// SetRootResource sets the URN of the root resource.
        pub async fn set_root_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRootResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::SetRootResourceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Engine/SetRootResource");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "SetRootResource"));
            self.inner.unary(req, path, codec).await
        }
        /// StartDebugging indicates to the engine that the program has started under a debugger, and the engine
        /// should notify the user of how to connect to the debugger.
        pub async fn start_debugging(
            &mut self,
            request: impl tonic::IntoRequest<super::StartDebuggingRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Engine/StartDebugging");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Engine", "StartDebugging"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod engine_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with EngineServer.
    #[async_trait]
    pub trait Engine: std::marker::Send + std::marker::Sync + 'static {
        /// Log logs a global message in the engine, including errors and warnings.
        async fn log(
            &self,
            request: tonic::Request<super::LogRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// GetRootResource gets the URN of the root resource, the resource that should be the root of all
        /// otherwise-unparented resources.
        async fn get_root_resource(
            &self,
            request: tonic::Request<super::GetRootResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRootResourceResponse>, tonic::Status>;
        /// SetRootResource sets the URN of the root resource.
        async fn set_root_resource(
            &self,
            request: tonic::Request<super::SetRootResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::SetRootResourceResponse>, tonic::Status>;
        /// StartDebugging indicates to the engine that the program has started under a debugger, and the engine
        /// should notify the user of how to connect to the debugger.
        async fn start_debugging(
            &self,
            request: tonic::Request<super::StartDebuggingRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// Engine is an auxiliary service offered to language and resource provider plugins. Its main purpose today is
    /// to serve as a common logging endpoint, but it also serves as a state storage mechanism for language hosts
    /// that can't store their own global state.
    #[derive(Debug)]
    pub struct EngineServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> EngineServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for EngineServer<T>
    where
        T: Engine,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Engine/Log" => {
                    #[allow(non_camel_case_types)]
                    struct LogSvc<T: Engine>(pub Arc<T>);
                    impl<T: Engine> tonic::server::UnaryService<super::LogRequest> for LogSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LogRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Engine>::log(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LogSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/GetRootResource" => {
                    #[allow(non_camel_case_types)]
                    struct GetRootResourceSvc<T: Engine>(pub Arc<T>);
                    impl<T: Engine> tonic::server::UnaryService<super::GetRootResourceRequest>
                        for GetRootResourceSvc<T>
                    {
                        type Response = super::GetRootResourceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRootResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::get_root_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRootResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/SetRootResource" => {
                    #[allow(non_camel_case_types)]
                    struct SetRootResourceSvc<T: Engine>(pub Arc<T>);
                    impl<T: Engine> tonic::server::UnaryService<super::SetRootResourceRequest>
                        for SetRootResourceSvc<T>
                    {
                        type Response = super::SetRootResourceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetRootResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::set_root_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetRootResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.Engine/StartDebugging" => {
                    #[allow(non_camel_case_types)]
                    struct StartDebuggingSvc<T: Engine>(pub Arc<T>);
                    impl<T: Engine> tonic::server::UnaryService<super::StartDebuggingRequest> for StartDebuggingSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartDebuggingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Engine>::start_debugging(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartDebuggingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(empty_body());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for EngineServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Engine";
    impl<T> tonic::server::NamedService for EngineServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// `ProviderHandshakeRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Handshake) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProviderHandshakeRequest {
    /// The gRPC address of the engine handshaking with the provider. At a minimum, this address will expose an instance
    /// of the [](pulumirpc.Engine) service.
    #[prost(string, tag = "1")]
    pub engine_address: ::prost::alloc::string::String,
    /// A *root directory* where the provider's binary, `PulumiPlugin.yaml`, or other identifying source code is located.
    /// In the event that the provider is *not* being booted by the engine (e.g. in the case that the engine has been
    /// asked to attach to an existing running provider instance via a host/port number), this field will be empty.
    #[prost(string, optional, tag = "2")]
    pub root_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// A *program directory* in which the provider should execute. This is generally a subdirectory of the root
    /// directory, though this is not required. In the event that the provider is *not* being booted by the engine (e.g.
    /// in the case that the engine has been asked to attach to an existing running provider instance via a host/port
    /// number), this field will be empty.
    #[prost(string, optional, tag = "3")]
    pub program_directory: ::core::option::Option<::prost::alloc::string::String>,
}
/// `ProviderHandshakeResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Handshake) call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProviderHandshakeResponse {}
/// `ParameterizeRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Parameterize) call. A
/// `ParameterizeRequest` may contain either:
///
/// * a string array (`ParametersArgs`), intended to represent a set of command-line arguments so as to support
///    instantiating a parameterized provider from a command-line invocation (e.g. to generate an SDK).
/// * a byte array accompanied by a name and version (`ParametersValue`), intended to represent a parameter embedded in a
///    previously generated SDK.
///
/// Embedding parameter values in SDKs allows programs to consume parameterized providers without needing to know the
/// details of the parameterization. Allowing the representation embedded into an SDK to differ from that supplied on the
/// command-line permits providers to implement optimizations for the common, fast-path case (program execution), such as
/// embedding a generated schema as opposed to generating it on-demand for each resource registration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterizeRequest {
    #[prost(oneof = "parameterize_request::Parameters", tags = "1, 2")]
    pub parameters: ::core::option::Option<parameterize_request::Parameters>,
}
/// Nested message and enum types in `ParameterizeRequest`.
pub mod parameterize_request {
    /// A parameter value, represented as an array of strings, as might be provided by a command-line invocation, such as
    /// that used to generate an SDK.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParametersArgs {
        #[prost(string, repeated, tag = "1")]
        pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A parameter value, represented by an arbitrary array of bytes accompanied by a name and version. This is expected
    /// to be the format used by parameterized provider SDKs.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParametersValue {
        /// The sub-package name for this sub-schema parameterization.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The sub-package version for this sub-schema parameterization.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        /// The embedded value from the sub-package.
        #[prost(bytes = "vec", tag = "3")]
        pub value: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Parameters {
        /// Arguments from the command line.
        #[prost(message, tag = "1")]
        Args(ParametersArgs),
        /// Values from a generated SDK.
        #[prost(message, tag = "2")]
        Value(ParametersValue),
    }
}
/// `ParameterizeResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Parameterize) call. It
/// contains a name and version that can be used to identify the sub-package that now exists as a result of
/// parameterization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterizeResponse {
    /// The name of the sub-package parameterized.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the sub-package parameterized.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
    /// the schema version.
    #[prost(int32, tag = "1")]
    pub version: i32,
    /// the name of the sub-package to lookup
    #[prost(string, tag = "2")]
    pub subpackage_name: ::prost::alloc::string::String,
    /// the version of the sub-package to lookup
    #[prost(string, tag = "3")]
    pub subpackage_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaResponse {
    /// the JSON-encoded schema.
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
}
/// `ConfigureRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Configure) call. Requests
/// include both provider-specific inputs (`variables` or `args`) and provider-agnostic ("protocol") configuration
/// (`acceptSecrets`, `acceptResources`, and so on).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureRequest {
    /// :::{warning}
    /// `variables` is deprecated; `args` should be used instead wherever possible.
    /// :::
    ///
    /// A map of input properties for the provider. Compound values, such as nested objects, should be JSON encoded so
    /// that they too can be passed as strings. For instance, the following configuration:
    ///
    /// ```
    /// {
    ///    "a": 42,
    ///    "b": {
    ///      "c": "hello",
    ///      "d": true
    ///    }
    /// }
    /// ```
    ///
    /// should be encoded as:
    ///
    /// ```
    /// {
    ///    "a": "42",
    ///    "b": "{\"c\":\"hello\",\"d\":true}"
    /// }
    /// ```
    #[prost(map = "string, string", tag = "1")]
    pub variables:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// A map of input properties for the provider.
    ///
    /// :::{warning}
    /// `args` may include secrets. Because `ConfigureRequest` is sent before [](pulumirpc.ConfigureResponse) can specify
    /// whether or not the provider accepts secrets in general, providers *must* handle secrets if they appear in `args`.
    /// :::
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// True if and only if the caller supports secrets. If true, operations should return strongly typed secrets if the
    /// provider supports them also. *Must* be true if the caller has previously called
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "3")]
    pub accept_secrets: bool,
    /// True if and only if the caller supports strongly typed resources. If true, operations should return resources as
    /// strongly typed values if the provider supports them also. *Must* be true if the caller has previously called
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "4")]
    pub accept_resources: bool,
    /// True if and only if the caller supports sending old inputs as part of [](pulumirpc.ResourceProvider.Diff) and
    /// [](pulumirpc.ResourceProvider.Update) calls. If true, the provider should expect these fields to be populated in
    /// these calls. *Must* be true if the caller has previously called [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "5")]
    pub sends_old_inputs: bool,
    /// True if and only if the caller supports sending old inputs and outputs as part of
    /// [](pulumirpc.ResourceProvider.Delete) calls. If true, the provider should expect these fields to be populated in
    /// these calls. *Must* be true if the caller has previously called [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "6")]
    pub sends_old_inputs_to_delete: bool,
}
/// `ConfigureResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Configure) call. Its primary
/// purpose is to communicate features that the provider supports back to the caller.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigureResponse {
    /// True if and only if the provider supports secrets. If true, the caller should pass secrets as strongly typed
    /// values to the provider. *Must* be true if the provider implements [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "1")]
    pub accept_secrets: bool,
    /// True if and only if the provider supports the `preview` field on [](pulumirpc.ResourceProvider.Create) and
    /// [](pulumirpc.ResourceProvider.Update) calls. If true, the engine should invoke these calls with `preview` set to
    /// `true` during previews. *Must* be true if the provider implements [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "2")]
    pub supports_preview: bool,
    /// True if and only if the provider supports strongly typed resources. If true, the caller should pass resources as
    /// strongly typed values to the provider. *Must* be true if the provider implements
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "3")]
    pub accept_resources: bool,
    /// True if and only if the provider supports output values as inputs. If true, the engine should pass output values
    /// to the provider where possible. *Must* be true if the provider implements
    /// [](pulumirpc.ResourceProvider.Handshake).
    #[prost(bool, tag = "4")]
    pub accept_outputs: bool,
    /// True if the provider accepts and respects Autonaming configuration that the engine provides on behalf of user.
    #[prost(bool, tag = "5")]
    pub supports_autonaming_configuration: bool,
}
/// `ConfigureErrorMissingKeys` is the type of error details that may be sent in response to a
/// [](pulumirpc.ResourceProvider.Configure) call when required configuration keys are missing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureErrorMissingKeys {
    /// A list of required configuration keys that were not supplied.
    #[prost(message, repeated, tag = "1")]
    pub missing_keys: ::prost::alloc::vec::Vec<configure_error_missing_keys::MissingKey>,
}
/// Nested message and enum types in `ConfigureErrorMissingKeys`.
pub mod configure_error_missing_keys {
    /// The type of key-value pairs representing keys that are missing from a [](pulumirpc.ResourceProvider.Configure)
    /// call.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MissingKey {
        /// The name of the missing configuration key.
        ///
        /// :::{note}
        /// This should be the *Pulumi name* of the missing key, and not any provider-internal or upstream name. Names
        /// that differ between Pulumi and an upstream provider should be translated prior to being returned.
        /// :::
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// A description of the missing config key, as reported by the provider.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeResponse {
    /// the returned values, if invoke was successful.
    #[prost(message, optional, tag = "1")]
    pub r#return: ::core::option::Option<::prost_types::Struct>,
    /// the failures if any arguments didn't pass verification.
    #[prost(message, repeated, tag = "2")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// a map from argument keys to the dependencies of the argument.
    #[prost(map = "string, message", tag = "3")]
    pub arg_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        call_request::ArgumentDependencies,
    >,
    /// the project name.
    #[prost(string, tag = "6")]
    pub project: ::prost::alloc::string::String,
    /// the name of the stack being deployed into.
    #[prost(string, tag = "7")]
    pub stack: ::prost::alloc::string::String,
    /// the configuration variables to apply before running.
    #[prost(map = "string, string", tag = "8")]
    pub config:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// the configuration keys that have secret values.
    #[prost(string, repeated, tag = "9")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// true if we're only doing a dryrun (preview).
    #[prost(bool, tag = "10")]
    pub dry_run: bool,
    /// the degree of parallelism for resource operations (<=1 for serial).
    #[prost(int32, tag = "11")]
    pub parallel: i32,
    /// the address for communicating back to the resource monitor.
    #[prost(string, tag = "12")]
    pub monitor_endpoint: ::prost::alloc::string::String,
    /// the organization of the stack being deployed into.
    #[prost(string, tag = "14")]
    pub organization: ::prost::alloc::string::String,
    /// the engine can be passed output values back, returnDependencies can be left blank if returning output values.
    #[prost(bool, tag = "17")]
    pub accepts_output_values: bool,
}
/// Nested message and enum types in `CallRequest`.
pub mod call_request {
    /// ArgumentDependencies describes the resources that a particular argument depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArgumentDependencies {
        /// A list of URNs this argument depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallResponse {
    /// the returned values, if call was successful.
    #[prost(message, optional, tag = "1")]
    pub r#return: ::core::option::Option<::prost_types::Struct>,
    /// the failures if any arguments didn't pass verification.
    #[prost(message, repeated, tag = "3")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
    /// a map from return value keys to the dependencies of the return value.
    ///
    /// returnDependencies will be augmented by the set of dependencies specified in return
    /// via output property values.
    #[prost(map = "string, message", tag = "2")]
    pub return_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        call_response::ReturnDependencies,
    >,
}
/// Nested message and enum types in `CallResponse`.
pub mod call_response {
    /// ReturnDependencies describes the resources that a particular return value depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReturnDependencies {
        /// A list of URNs this return value depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// `CheckRequest` is the type of requests sent as part of [](pulumirpc.ResourceProvider.CheckConfig) and
/// [](pulumirpc.ResourceProvider.Check) calls. A `CheckRequest` primarily captures the URN and inputs of the resource
/// being checked. In the case of [](pulumirpc.ResourceProvider.CheckConfig), the URN will be the URN of the provider
/// resource being constructed, which may or may not be a [default provider](default-providers), and the inputs will be
/// the provider configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRequest {
    /// The URN of the resource whose inputs are being checked. In the case of
    /// [](pulumirpc.ResourceProvider.CheckConfig), this will be the URN of the provider resource being constructed,
    /// which may or may not be a [default provider](default-providers).
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// The old input properties or configuration for the resource, if any.
    #[prost(message, optional, tag = "2")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new input properties or configuration for the resource, if any.
    ///
    /// :::{note}
    /// If this resource has been specified with the
    /// [`ignoreChanges`](<https://www.pulumi.com/docs/concepts/options/ignorechanges/>), then the values in `news` may
    /// differ from those written in the Pulumi program registering this resource. In such cases, the caller (e.g. the
    /// Pulumi engine) is expected to preprocess the `news` value by replacing every property matched by `ignoreChanges`
    /// with its corresponding `olds` value (effectively ignoring the change).
    /// :::
    #[prost(message, optional, tag = "3")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A random but deterministically computed hash, intended to be used for generating globally unique names.
    #[prost(bytes = "vec", tag = "5")]
    pub random_seed: ::prost::alloc::vec::Vec<u8>,
    /// The name of the resource being checked. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being checked. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub autonaming: ::core::option::Option<check_request::AutonamingOptions>,
}
/// Nested message and enum types in `CheckRequest`.
pub mod check_request {
    /// Configuration for automatic resource naming behavior. This structure contains fields that control how the provider
    /// handles resource names, including proposed names and naming modes.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutonamingOptions {
        /// The proposed name for the resource being checked. This may be used by the provider as a suggestion
        /// for the final resource name, depending on the specified mode.
        #[prost(string, tag = "1")]
        pub proposed_name: ::prost::alloc::string::String,
        #[prost(enumeration = "autonaming_options::Mode", tag = "2")]
        pub mode: i32,
    }
    /// Nested message and enum types in `AutonamingOptions`.
    pub mod autonaming_options {
        /// The mode that controls how the provider handles the proposed name. If not specified, defaults to `PROPOSE`.
        /// - `PROPOSE`: The provider may use the proposed name as a suggestion but is free to modify it.
        /// - `ENFORCE`: The provider must use exactly the proposed name or return an error.
        /// - `DISABLE`: The provider should disable automatic naming and return an error if no explicit name
        ///    is provided by user's program.
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Mode {
            Propose = 0,
            Enforce = 1,
            Disable = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Propose => "PROPOSE",
                    Self::Enforce => "ENFORCE",
                    Self::Disable => "DISABLE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROPOSE" => Some(Self::Propose),
                    "ENFORCE" => Some(Self::Enforce),
                    "DISABLE" => Some(Self::Disable),
                    _ => None,
                }
            }
        }
    }
}
/// `CheckResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.CheckConfig) or
/// [](pulumirpc.ResourceProvider.Check) call. A `CheckResponse` may contain either:
///
/// * a set of checked, known-valid `inputs`. In the case of [](pulumirpc.ResourceProvider.CheckConfig), these may
///    subsequently be passed to [](pulumirpc.ResourceProvider.DiffConfig) and/or
///    [](pulumirpc.ResourceProvider.Configure). In the case of [](pulumirpc.ResourceProvider.Check), these may be passed
///    to any of the supported lifecycle methods that accept provider inputs.
/// * a set of `failures` detailing invalid inputs.
///
/// In cases where the supplied set of inputs is valid, a `CheckResponse` may contain default values that should
/// persisted to Pulumi state and passed to subsequent calls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResponse {
    /// A valid, checked set of inputs. May contain defaults.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// Any validation failures that occurred.
    #[prost(message, repeated, tag = "2")]
    pub failures: ::prost::alloc::vec::Vec<CheckFailure>,
}
/// A `CheckFailure` describes a single validation error that arose as part of a
/// [](pulumirpc.ResourceProvider.CheckConfig) or [](pulumirpc.ResourceProvider.Check) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckFailure {
    /// The input property that failed validation.
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    /// The reason that the named property failed validation.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// `DiffRequest` is the type of requests sent as part of [](pulumirpc.ResourceProvider.DiffConfig) and
/// [](pulumirpc.ResourceProvider.Diff) calls. A `DiffRequest` primarily captures:
///
/// * the URN of the resource whose properties are being compared;
/// * the old and new input properties of the resource; and
/// * the old output properties of the resource.
///
/// In the case of [](pulumirpc.ResourceProvider.DiffConfig), the URN will be the URN of the provider resource being
/// examined, which may or may not be a [default provider](default-providers), and the inputs and outputs will be the
/// provider configuration and state. Inputs supplied to a [](pulumirpc.ResourceProvider.DiffConfig) call should have
/// been previously checked by a call to [](pulumirpc.ResourceProvider.CheckConfig); inputs supplied to a
/// [](pulumirpc.ResourceProvider.Diff) call should have been previously checked by a call to
/// [](pulumirpc.ResourceProvider.Check).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiffRequest {
    /// The ID of the resource being diffed.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being diffed.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being diffed.
    #[prost(message, optional, tag = "3")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new *input* properties of the resource being diffed. These should have been validated by an appropriate call
    /// to [](pulumirpc.ResourceProvider.CheckConfig) or [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "4")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "5")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The old *input* properties of the resource being diffed.
    #[prost(message, optional, tag = "6")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being diffed. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being diffed. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "8")]
    pub r#type: ::prost::alloc::string::String,
}
/// `PropertyDiff` describes the kind of change that occurred to a property during a diff operation. A `PropertyDiff` may
/// indicate that a property was added, deleted, or updated, and may further indicate that the change requires a
/// replacement.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PropertyDiff {
    /// The kind of diff associated with this property.
    #[prost(enumeration = "property_diff::Kind", tag = "1")]
    pub kind: i32,
    /// True if and only if this difference represents one between a pair of old and new inputs, as opposed to a pair of
    /// old and new states.
    #[prost(bool, tag = "2")]
    pub input_diff: bool,
}
/// Nested message and enum types in `PropertyDiff`.
pub mod property_diff {
    /// The type of property diff kinds.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Kind {
        /// This property was added.
        Add = 0,
        /// This property was added, and this change requires a replace.
        AddReplace = 1,
        /// This property was removed.
        Delete = 2,
        /// This property was removed, and this change requires a replace.
        DeleteReplace = 3,
        /// This property's value was changed.
        Update = 4,
        /// This property's value was changed, and this change requires a replace.
        UpdateReplace = 5,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Add => "ADD",
                Self::AddReplace => "ADD_REPLACE",
                Self::Delete => "DELETE",
                Self::DeleteReplace => "DELETE_REPLACE",
                Self::Update => "UPDATE",
                Self::UpdateReplace => "UPDATE_REPLACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADD" => Some(Self::Add),
                "ADD_REPLACE" => Some(Self::AddReplace),
                "DELETE" => Some(Self::Delete),
                "DELETE_REPLACE" => Some(Self::DeleteReplace),
                "UPDATE" => Some(Self::Update),
                "UPDATE_REPLACE" => Some(Self::UpdateReplace),
                _ => None,
            }
        }
    }
}
/// `DiffResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.DiffConfig) or
/// [](pulumirpc.ResourceProvider.Diff) call. A `DiffResponse` indicates whether a resource is unchanged, requires
/// updating (that is, can be changed "in place"), or requires replacement (that is, must be destroyed and recreated
/// anew). Legacy implementations may also signal that it is unknown whether there are changes or not.
///
/// `DiffResponse` has evolved since its inception and there are now a number of ways that providers can signal their
/// intent to callers:
///
/// * *Simple diffs* utilise the `changes` field to signal which fields are responsible for a change, and the `replaces`
///    field to further communicate which changes (if any) require a replacement as opposed to an update.
///
/// * *Detailed diffs* are those with `hasDetailedDiff` set, and utilise the `detailedDiff` field to provide a more
///    granular view of the changes that have occurred. Detailed diffs are designed to allow providers to control
///    precisely which field names are displayed as responsible for a change, and to signal more accurately what kind of
///    change occurred (e.g. a field was added, deleted or updated).
///
/// The response must satisfy the following invariants:
///
/// * For each top-level key in `diff` there is at least one matching property path, starting at that key, in `detailedDiff`.
/// * For each entry in `detailedDiff`, its top-level property is in `diff`.
/// * `diff` does not contain duplicates.
/// * `detailedDiff` does not contain duplicate keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiffResponse {
    /// A set of properties which have changed and whose changes require the resource being diffed to be replaced. The
    /// caller should replace the resource if this set is non-empty, or if any of the properties specified in
    /// `detailedDiff` have a `*_REPLACE` kind.
    #[prost(string, repeated, tag = "1")]
    pub replaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// An optional list of properties that will not ever change (are stable).
    #[prost(string, repeated, tag = "2")]
    pub stables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, this resource must be deleted *before* its replacement is created.
    #[prost(bool, tag = "3")]
    pub delete_before_replace: bool,
    /// The result of the diff. Indicates at a high level whether the resource has changed or not (or, in legacy cases,
    /// if the provider does not know).
    #[prost(enumeration = "diff_response::DiffChanges", tag = "4")]
    pub changes: i32,
    /// The set of properties which have changed. This field only supports top-level properties. It *does not* support
    /// full [property paths](property-paths); implementations should use `detailedDiff` when this is required.
    #[prost(string, repeated, tag = "5")]
    pub diffs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// `detailedDiff` can be used to implement more detailed diffs. A detailed diff is a map from [property
    /// paths](property-paths) to [](pulumirpc.PropertyDiff)s, which describe the kind of change that occurred to the
    /// property located at that path. If a provider does not implement this, the caller (typically the Pulumi engine)
    /// will compute a representation based on the simple diff fields (`changes`, `replaces`, and so on).
    #[prost(map = "string, message", tag = "6")]
    pub detailed_diff: ::std::collections::HashMap<::prost::alloc::string::String, PropertyDiff>,
    /// True if and only if this response contains a `detailedDiff`.
    #[prost(bool, tag = "7")]
    pub has_detailed_diff: bool,
}
/// Nested message and enum types in `DiffResponse`.
pub mod diff_response {
    /// The type of high-level diff results.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DiffChanges {
        /// A diff was performed but it is unknown whether there are changes or not. This exists to support legacy
        /// behaviour and should be generally avoided wherever possible.
        DiffUnknown = 0,
        /// A diff was performed and there were no changes. An update is not required.
        DiffNone = 1,
        /// A diff was performed, and changes were detected that require an update or replacement.
        DiffSome = 2,
    }
    impl DiffChanges {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DiffUnknown => "DIFF_UNKNOWN",
                Self::DiffNone => "DIFF_NONE",
                Self::DiffSome => "DIFF_SOME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIFF_UNKNOWN" => Some(Self::DiffUnknown),
                "DIFF_NONE" => Some(Self::DiffNone),
                "DIFF_SOME" => Some(Self::DiffSome),
                _ => None,
            }
        }
    }
}
/// `CreateRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Create) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    /// The URN of the resource being created.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// The resource's input properties, to be set during creation. These should have been validated by a call to
    /// [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "3")]
    pub timeout: f64,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually create the resource.
    #[prost(bool, tag = "4")]
    pub preview: bool,
    /// The name of the resource being created. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being created. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
}
/// `CreateResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Create) call. A `CreateResponse`
/// contains the ID of the created resource, as well as any output properties that arose from the creation process.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResponse {
    /// The ID of the created resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The resource's output properties. Typically this will be a union of the resource's input properties and any
    /// additional values that were computed or made available during creation.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
}
/// `ReadRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Read) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    /// The ID of the resource to read.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being read.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// Any current state for the resource being read. This state should be sufficient to uniquely identify the resource.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Any current input properties for the resource being read. These will only be populated when the
    /// [](pulumirpc.ResourceProvider.Read) call is being made as part of a refresh operation.
    #[prost(message, optional, tag = "4")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being read. This must match the name specified by the `urn` field, and is passed so that
    /// providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being read. This must match the type specified by the `urn` field, and is passed so that
    /// providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
}
/// `ReadResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Read) call. A `ReadResponse` contains
/// the ID of the resource being read, as well as any state that was successfully read from the live environment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    /// The ID of the read resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The output properties of the resource read from the live environment.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// Output-derived input properties for the resource. These are returned as they would be returned from a
    /// [](pulumirpc.ResourceProvider.Check) call with the same values.
    #[prost(message, optional, tag = "3")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
}
/// `UpdateRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Update) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRequest {
    /// The ID of the resource being updated.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource being updated.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being updated.
    #[prost(message, optional, tag = "3")]
    pub olds: ::core::option::Option<::prost_types::Struct>,
    /// The new input properties of the resource being updated. These should have been validated by a call to
    /// [](pulumirpc.ResourceProvider.Check).
    #[prost(message, optional, tag = "4")]
    pub news: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "5")]
    pub timeout: f64,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "6")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually update the resource.
    #[prost(bool, tag = "7")]
    pub preview: bool,
    /// The old *input* properties of the resource being updated.
    #[prost(message, optional, tag = "8")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being updated. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "9")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being updated. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "10")]
    pub r#type: ::prost::alloc::string::String,
}
/// `UpdateResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Update) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResponse {
    /// An updated set of resource output properties. Typically this will be a union of the resource's inputs and any
    /// additional values that were computed or made available during the update.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
}
/// `DeleteRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Delete) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    /// The ID of the resource to delete.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The URN of the resource to delete.
    #[prost(string, tag = "2")]
    pub urn: ::prost::alloc::string::String,
    /// The old *output* properties of the resource being deleted.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// A timeout in seconds that the caller is prepared to wait for the operation to complete.
    #[prost(double, tag = "4")]
    pub timeout: f64,
    /// The old *input* properties of the resource being deleted.
    ///
    /// the old input values of the resource to delete.
    #[prost(message, optional, tag = "5")]
    pub old_inputs: ::core::option::Option<::prost_types::Struct>,
    /// The name of the resource being deleted. This must match the name specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// The type of the resource being deleted. This must match the type specified by the `urn` field, and is passed so
    /// that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
}
/// `ConstructRequest` is the type of requests sent as part of a [](pulumirpc.ResourceProvider.Construct) call. A
/// `ConstructRequest` captures enough data to be able to register nested components against the caller's resource
/// monitor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstructRequest {
    /// The project to which this resource and its nested resources will belong.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// The name of the stack being deployed into.
    #[prost(string, tag = "2")]
    pub stack: ::prost::alloc::string::String,
    /// Configuration for the specified project and stack.
    #[prost(map = "string, string", tag = "3")]
    pub config:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// True if and only if the request is being made as part of a preview/dry run, in which case the provider should not
    /// actually construct the component.
    #[prost(bool, tag = "4")]
    pub dry_run: bool,
    /// The degree of parallelism that may be used for resource operations. A value less than or equal to 1 indicates
    /// that operations should be performed serially.
    #[prost(int32, tag = "5")]
    pub parallel: i32,
    /// The address of the [](pulumirpc.ResourceMonitor) that the provider should connect to in order to send [resource
    /// registrations](resource-registration) for its nested resources.
    #[prost(string, tag = "6")]
    pub monitor_endpoint: ::prost::alloc::string::String,
    /// The type of the component resource being constructed. This must match the type specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the type of the resource.
    #[prost(string, tag = "7")]
    pub r#type: ::prost::alloc::string::String,
    /// The name of the component resource being constructed. This must match the name specified by the `urn` field, and
    /// is passed so that providers do not have to implement URN parsing in order to extract the name of the resource.
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
    /// An optional parent resource that the component (and by extension, its nested resources) should be children of.
    #[prost(string, tag = "9")]
    pub parent: ::prost::alloc::string::String,
    /// The component resource's input properties. Unlike the inputs of custom resources, these will *not* have been
    /// passed to a call to [](pulumirpc.ResourceProvider.Check). By virtue of their being a composition of other
    /// resources, component resources are able to (and therefore expected) to validate their own inputs. Moreover,
    /// [](pulumirpc.ResourceProvider.Check) will be called on any inputs passed to nested custom resources as usual.
    #[prost(message, optional, tag = "10")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
    /// A map of property dependencies for the component resource and its nested resources.
    #[prost(map = "string, message", tag = "11")]
    pub input_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        construct_request::PropertyDependencies,
    >,
    /// A map of package names to provider references for the component resource and its nested resources.
    #[prost(map = "string, string", tag = "13")]
    pub providers:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// A list of URNs that this resource and its nested resources depend on.
    #[prost(string, repeated, tag = "15")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A set of configuration keys whose values are [secret](output-secrets).
    #[prost(string, repeated, tag = "16")]
    pub config_secret_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The organization to which this resource and its nested resources will belong.
    #[prost(string, tag = "17")]
    pub organization: ::prost::alloc::string::String,
    /// True if and only if the resource (and by extension, its nested resources) should be marked as protected.
    /// Protected resources cannot be deleted without first being unprotected.
    #[prost(bool, tag = "12")]
    pub protect: bool,
    /// A list of additional URNs that should be considered the same as this component's URN (and which will therefore be
    /// used to build aliases for its nested resource URNs). These may be URNs that previously referred to this component
    /// e.g. if it had its parent (and consequently URN) changed.
    #[prost(string, repeated, tag = "14")]
    pub aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of input properties whose values should be treated as [secret](output-secrets).
    #[prost(string, repeated, tag = "18")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A set of custom timeouts that specify how long the caller is prepared to wait for the various CRUD operations of
    /// this resource's nested resources.
    #[prost(message, optional, tag = "19")]
    pub custom_timeouts: ::core::option::Option<construct_request::CustomTimeouts>,
    /// The URN of a resource that this resource (and thus its nested resources) will be implicitly deleted with. If the
    /// resource referred to by this URN is deleted in the same operation that this resource would be deleted, the
    /// [](pulumirpc.ResourceProvider.Delete) call for this resource will be elided (since this dependency signals that
    /// it will have already been deleted).
    #[prost(string, tag = "20")]
    pub deleted_with: ::prost::alloc::string::String,
    /// If true, this resource (and its nested resources) must be deleted *before* its replacement is created.
    #[prost(bool, tag = "21")]
    pub delete_before_replace: bool,
    /// A set of [property paths](property-paths) that should be treated as unchanged.
    #[prost(string, repeated, tag = "22")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A set of properties that, when changed, trigger a replacement.
    #[prost(string, repeated, tag = "23")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if [](pulumirpc.ResourceProvider.Delete) should *not* be called when the resource (and by extension, its
    /// nested resources) are removed from a Pulumi program.
    #[prost(bool, tag = "24")]
    pub retain_on_delete: bool,
    /// True if the caller is capable of accepting output values in response to the call. If this is set, these outputs
    /// may be used to communicate dependency information and so there is no need to populate
    /// [](pulumirpc.ConstructResponse)'s `stateDependencies` field.
    #[prost(bool, tag = "25")]
    pub accepts_output_values: bool,
}
/// Nested message and enum types in `ConstructRequest`.
pub mod construct_request {
    /// A `PropertyDependencies` list is a set of URNs that a particular property may depend on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs that this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A `CustomTimeouts` object encapsulates a set of timeouts for the various CRUD operations that might be performed
    /// on this resource's nested resources. Timeout values are specified as duration strings, such as `"5ms"` (5
    /// milliseconds), `"40s"` (40 seconds), or `"1m30s"` (1 minute and 30 seconds). The following units of time are
    /// supported:
    ///
    /// * `ns`: nanoseconds
    /// * `us` or `s`: microseconds
    /// * `ms`: milliseconds
    /// * `s`: seconds
    /// * `m`: minutes
    /// * `h`: hours
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomTimeouts {
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Create) operation
        /// to complete.
        #[prost(string, tag = "1")]
        pub create: ::prost::alloc::string::String,
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Update) operation
        /// to complete.
        #[prost(string, tag = "2")]
        pub update: ::prost::alloc::string::String,
        /// How long a caller is prepared to wait for a nested resource's [](pulumirpc.ResourceProvider.Delete) operation
        /// to complete.
        #[prost(string, tag = "3")]
        pub delete: ::prost::alloc::string::String,
    }
}
/// `ConstructResponse` is the type of responses sent by a [](pulumirpc.ResourceProvider.Construct) call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstructResponse {
    /// The URN of the constructed component resource.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// Any output properties that the component registered as part of its construction.
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<::prost_types::Struct>,
    /// A map of property dependencies for the component's outputs. This will be set if the caller indicated that it
    /// could not receive dependency-communicating [output](outputs) values by setting [](pulumirpc.ConstructRequest)'s
    /// `accepts_output_values` field to false.
    #[prost(map = "string, message", tag = "3")]
    pub state_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        construct_response::PropertyDependencies,
    >,
}
/// Nested message and enum types in `ConstructResponse`.
pub mod construct_response {
    /// A `PropertyDependencies` list is a set of URNs that a particular property may depend on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs that this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// ErrorResourceInitFailed is sent as a Detail `ResourceProvider.{Create, Update}` fail because a
/// resource was created successfully, but failed to initialize.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResourceInitFailed {
    /// the ID of the created resource.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// any properties that were computed during updating.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// error messages associated with initialization failure.
    #[prost(string, repeated, tag = "3")]
    pub reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the current inputs to this resource (only applicable for Read)
    #[prost(message, optional, tag = "4")]
    pub inputs: ::core::option::Option<::prost_types::Struct>,
}
/// GetMappingRequest allows providers to return ecosystem specific information to allow the provider to be
/// converted from a source markup to Pulumi. It's expected that provider bridges that target a given ecosystem
/// (e.g. Terraform, Kubernetes) would also publish a conversion plugin to convert markup from that ecosystem
/// to Pulumi, using the bridged providers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingRequest {
    /// the conversion key for the mapping being requested.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// the optional provider key for the mapping being requested, if this is empty the provider should assume this
    /// request is from an old engine from before GetMappings and should return it's "primary" mapping. If this is set
    /// then the `provider` field in GetMappingResponse should be the same.
    #[prost(string, tag = "2")]
    pub provider: ::prost::alloc::string::String,
}
/// GetMappingResponse returns convert plugin specific data for this provider. This will normally be human
/// readable JSON, but the engine doesn't mandate any form.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingResponse {
    /// the provider key this is mapping for. For example the Pulumi provider "terraform-template" would return "template" for this.
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    /// the conversion plugin specific data.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// GetMappingsRequest allows providers to return ecosystem specific information without having to send back large data
/// blobs for provider mappings that the engine doesn't then need.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingsRequest {
    /// the conversion key for the mapping being requested.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
/// GetMappingsRequest returns a list of providers that this provider can provide mapping information for.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMappingsResponse {
    /// the provider keys this provider can supply mappings for. For example the Pulumi provider "terraform-template"
    /// would return \["template"\] for this.
    #[prost(string, repeated, tag = "1")]
    pub providers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod resource_provider_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The ResourceProvider service defines a standard interface for [resource providers](providers). A resource provider
    /// manages a set of configuration, resources, functions and so on in a single package, and offers methods such as CRUD
    /// operations on resources and invocations of functions. Resource providers are primarily managed by the Pulumi engine
    /// as part of a deployment in order to interact with the cloud providers underpinning a Pulumi application.
    #[derive(Debug, Clone)]
    pub struct ResourceProviderClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ResourceProviderClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ResourceProviderClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResourceProviderClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ResourceProviderClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// `Handshake` is the first call made by the engine to a provider. It is used to pass the engine's address to the
        /// provider so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties. Providers that support `Handshake` implicitly support the set of
        /// feature flags previously handled by `Configure` prior to `Handshake`'s introduction, such as secrets and resource
        /// references.
        pub async fn handshake(
            &mut self,
            request: impl tonic::IntoRequest<super::ProviderHandshakeRequest>,
        ) -> std::result::Result<tonic::Response<super::ProviderHandshakeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Handshake");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Handshake"));
            self.inner.unary(req, path, codec).await
        }
        /// `Parameterize` is the primary means of supporting [parameterized providers](parameterized-providers), which allow
        /// a caller to change a provider's behavior ahead of its [configuration](pulumirpc.ResourceProvider.Configure) and
        /// subsequent use. Where a [](pulumirpc.ResourceProvider.Configure) call allows a caller to influence provider
        /// behaviour at a high level (e.g. by specifying the region in which an AWS provider should operate), a
        /// `Parameterize` call may change the set of resources and functions that a provider offers (that is, its schema).
        /// This is useful in any case where some "set" of providers can be captured by a single implementation that may
        /// power fundamentally different schemata -- dynamically bridging Terraform providers, or managing Kubernetes
        /// clusters with custom resource definitions, for instance, are good examples. The parameterized package that
        /// `Parameterize` yields is known as a *sub-package* of the original (unparameterized) package.
        ///
        /// `Parameterize` supports two types of parameterization:
        ///
        /// * *Replacement parameterization*, whereby a `Parameterize` call results in a schema that completely replaces the
        ///   original provider schema. Bridging a Terraform provider dynamically might be an example of this -- following
        ///   the call to `Parameterize`, the provider's schema will become that of the Terraform provider that was bridged.
        ///   Providers that implement replacement parameterization expect a *single* call to `Parameterize`.
        ///
        /// * *Extension parameterization*, in which a `Parameterize` call results in a schema that is a superset of the
        ///   original. This is useful in cases where a provider can be extended with additional resources or functions, such
        ///   as a Kubernetes provider that can be extended with resources representing custom resource definitions.
        ///   Providers that implement extension parameterization should accept multiple calls to `Parameterize`. Extension
        ///   packages may even be called multiple times with the same package name, but with different versions. The CRUD
        ///   operations of extension resources must include the version of which sub-package they correspond to.
        ///
        /// `Parameterize` should work the same whether it is provided with `ParametersArgs` or `ParametersValue` input. In
        /// each case it should return the sub-package name and version (which when a `ParametersValue` is supplied should
        /// match the given input).
        pub async fn parameterize(
            &mut self,
            request: impl tonic::IntoRequest<super::ParameterizeRequest>,
        ) -> std::result::Result<tonic::Response<super::ParameterizeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Parameterize");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceProvider",
                "Parameterize",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetSchema fetches the schema for this resource provider.
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSchemaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/GetSchema");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetSchema"));
            self.inner.unary(req, path, codec).await
        }
        /// `CheckConfig` validates a set of configuration inputs that will be passed to this provider instance.
        /// `CheckConfig` is to provider resources what [](pulumirpc.ResourceProvider.Check) is to individual resources, and
        /// is the first stage in configuring (that is, eventually executing a [](pulumirpc.ResourceProvider.Configure) call)
        /// a provider using user-supplied values. In the case that provider inputs are coming from some source that has been
        /// checked previously (e.g. a Pulumi state), it is not necessary to call `CheckConfig`.
        ///
        /// A `CheckConfig` call returns either a set of checked, known-valid inputs that may subsequently be passed to
        /// [](pulumirpc.ResourceProvider.DiffConfig) and/or [](pulumirpc.ResourceProvider.Configure), or a set of errors
        /// explaining why the inputs are invalid. In the case that a set of inputs are successfully validated and returned,
        /// `CheckConfig` *may also populate default values* for provider configuration, returning them so that they may be
        /// passed to a subsequent [](pulumirpc.ResourceProvider.Configure) call and persisted in the Pulumi state. In the
        /// case that `CheckConfig` fails and returns a set of errors, it is expected that the caller (typically the Pulumi
        /// engine) will fail provider registration.
        ///
        /// As a rule, the provider inputs returned by a call to `CheckConfig` should preserve the original representation of
        /// the properties as present in the program inputs. Though this rule is not required for correctness, violations
        /// thereof can negatively impact the end-user experience, as the provider inputs are used for detecting and
        /// rendering diffs.
        pub async fn check_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/CheckConfig");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "CheckConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// `DiffConfig` compares an existing ("old") provider configuration with a new configuration and computes the
        /// difference (if any) between them. `DiffConfig` is to provider resources what [](pulumirpc.ResourceProvider.Diff)
        /// is to individual resources. `DiffConfig` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.CheckConfig) call. The [](pulumirpc.DiffResponse) returned by a `DiffConfig`
        /// call is used primarily to determine whether or not the newly configured provider is capable of managing resources
        /// owned by the old provider. If `DiffConfig` indicates that the provider resource needs to be replaced, for
        /// instance, then all resources owned by that provider will *also* need to be replaced. Replacement semantics should
        /// thus be reserved for changes to configuration properties that are guaranteed to make old resources unmanageable.
        /// Changes to an AWS region, for example, will almost certainly require a provider replacement, but changes to an
        /// AWS access key, should almost certainly not.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        pub async fn diff_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/DiffConfig");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "DiffConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// `Configure` is the final stage in configuring a provider instance. Callers may supply two sets of data:
        ///
        /// * Provider-specific configuration, which is the set of inputs that have been validated by a previous
        ///   [](pulumirpc.ResourceProvider.CheckConfig) call.
        /// * Provider-agnostic ("protocol") configuration, such as whether or not the caller supports secrets.
        ///
        /// The provider is expected to return its own set of protocol configuration, indicating which features it supports
        /// in turn so that the caller and the provider can interact appropriately.
        ///
        /// Providers may expect a *single* call to `Configure`. If a call to `Configure` is missing required configuration,
        /// the provider may return a set of error details containing [](pulumirpc.ConfigureErrorMissingKeys) values to
        /// indicate which keys are missing.
        ///
        /// :::{important}
        /// The use of `Configure` to configure protocol features is deprecated in favour of the
        /// [](pulumirpc.ResourceProvider.Handshake) method, which should be implemented by newer providers. To enable
        /// compatibility between older engines and providers:
        ///
        /// * Callers which call `Handshake` *must* call `Configure` with flags such as `acceptSecrets` and `acceptResources`
        ///   set to `true`, since these features predate the introduction of `Handshake` and thus `Handshake`-aware callers
        ///   must support them. See [](pulumirpc.ConfigureRequest) for more information.
        /// * Providers which implement `Handshake` *must* support flags such as `acceptSecrets` and `acceptResources`, and
        ///   indicate as such by always returning `true` for these fields in [](pulumirpc.ConfigureResponse). See
        ///   [](pulumirpc.ConfigureResponse) for more information.
        /// :::
        pub async fn configure(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfigureRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigureResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Configure");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Configure"));
            self.inner.unary(req, path, codec).await
        }
        /// Invoke dynamically executes a built-in function in the provider.
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Invoke");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
        /// StreamInvoke dynamically executes a built-in function in the provider, which returns a stream
        /// of responses.
        pub async fn stream_invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InvokeResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/StreamInvoke");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceProvider",
                "StreamInvoke",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Call dynamically executes a method in the provider associated with a component resource.
        pub async fn call(
            &mut self,
            request: impl tonic::IntoRequest<super::CallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Call");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Call"));
            self.inner.unary(req, path, codec).await
        }
        /// `Check` validates a set of input properties against a given resource type. A `Check` call returns either a set of
        /// checked, known-valid inputs that may subsequently be passed to [](pulumirpc.ResourceProvider.Diff),
        /// [](pulumirpc.ResourceProvider.Create), or [](pulumirpc.ResourceProvider.Update); or a set of errors explaining
        /// why the inputs are invalid. In the case that a set of inputs are successfully validated and returned, `Check`
        /// *may also populate default values* for resource inputs, returning them so that they may be passed to a subsequent
        /// call and persisted in the Pulumi state. In the case that `Check` fails and returns a set of errors, it is
        /// expected that the caller (typically the Pulumi engine) will fail resource registration.
        ///
        /// As a rule, the provider inputs returned by a call to `Check` should preserve the original representation of the
        /// properties as present in the program inputs. Though this rule is not required for correctness, violations thereof
        /// can negatively impact the end-user experience, as the provider inputs are used for detecting and rendering
        /// diffs.
        pub async fn check(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Check");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Check"));
            self.inner.unary(req, path, codec).await
        }
        /// `Diff` compares an existing ("old") set of resource properties with a new set of properties and computes the
        /// difference (if any) between them. `Diff` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.Check) call.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        pub async fn diff(
            &mut self,
            request: impl tonic::IntoRequest<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Diff");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Diff"));
            self.inner.unary(req, path, codec).await
        }
        /// `Create` provisions a new instance of the specified [(custom) resource](custom-resources). It returns a
        /// provider-assigned ID for the resource as well as the output properties that arose from the creation properties.
        /// Output properties are typically the union of the resource's input properties and any additional values that were
        /// computed or made available during creation.
        ///
        /// If creation fails, `Create` may return an [](pulumirpc.ErrorResourceInitFailed) error detail explaining why.
        /// Moreover, if `Create` does return an error, it must be the case that the resource was *not* created (that is,
        /// `Create` can be thought of as transactional or atomic).
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Create");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Create"));
            self.inner.unary(req, path, codec).await
        }
        /// `Read` reads the current live state associated with a resource identified by the supplied state. The given state
        /// must be sufficient to uniquely identify the resource. This is typically just the resource ID, but may also
        /// include other properties.
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Read");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Read"));
            self.inner.unary(req, path, codec).await
        }
        /// `Update` updates an existing resource according to a new set of inputs, returning a new set of output properties.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Update");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Update"));
            self.inner.unary(req, path, codec).await
        }
        /// `Delete` deprovisions an existing resource as specified by its ID. `Delete` should be transactional/atomic -- if
        /// a call to `Delete` fails, it must be the case that the resource was *not* deleted and can be assumed to still
        /// exist.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Delete");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// `Construct` provisions a new [component resource](component-resources). Providers that implement `Construct` are
        /// referred to as [component providers](component-providers). `Construct` is to component resources what
        /// [](pulumirpc.ResourceProvider.Create) is to [custom resources](custom-resources). Components do not have any
        /// lifecycle of their own, and instead embody the lifecycles of the resources that they are composed of. As such,
        /// `Construct` is effectively a subprogram whose resources will be persisted in the caller's state. It is
        /// consequently passed enough information to manage fully these resources. At a high level, this comprises:
        ///
        /// * A [](pulumirpc.ResourceMonitor) endpoint which the provider can use to [register](resource-registration) nested
        ///   custom or component resources that belong to the component.
        ///
        /// * A set of input properties.
        ///
        /// * A full set of [resource options](https://www.pulumi.com/docs/iac/concepts/options/) that the component should
        ///   propagate to resources it registers against the supplied resource monitor.
        pub async fn construct(
            &mut self,
            request: impl tonic::IntoRequest<super::ConstructRequest>,
        ) -> std::result::Result<tonic::Response<super::ConstructResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Construct");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Construct"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel signals the provider to gracefully shut down and abort any ongoing resource operations.
        /// Operations aborted in this way will return an error (e.g., `Update` and `Create` will either return a
        /// creation error or an initialization error). Since Cancel is advisory and non-blocking, it is up
        /// to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Cancel");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
        /// GetPluginInfo returns generic information about this plugin, like its version.
        pub async fn get_plugin_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/GetPluginInfo");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceProvider",
                "GetPluginInfo",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Attach sends the engine address to an already running plugin.
        pub async fn attach(
            &mut self,
            request: impl tonic::IntoRequest<super::PluginAttach>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/Attach");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "Attach"));
            self.inner.unary(req, path, codec).await
        }
        /// GetMapping fetches the mapping for this resource provider, if any. A provider should return an empty
        /// response (not an error) if it doesn't have a mapping for the given key.
        pub async fn get_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMappingRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMappingResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/GetMapping");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetMapping"));
            self.inner.unary(req, path, codec).await
        }
        /// GetMappings is an optional method that returns what mappings (if any) a provider supports. If a provider does not
        /// implement this method the engine falls back to the old behaviour of just calling GetMapping without a name.
        /// If this method is implemented than the engine will then call GetMapping only with the names returned from this method.
        pub async fn get_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMappingsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMappingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceProvider/GetMappings");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceProvider", "GetMappings"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod resource_provider_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ResourceProviderServer.
    #[async_trait]
    pub trait ResourceProvider: std::marker::Send + std::marker::Sync + 'static {
        /// `Handshake` is the first call made by the engine to a provider. It is used to pass the engine's address to the
        /// provider so that it may establish its own connections back, and to establish protocol configuration that will be
        /// used to communicate between the two parties. Providers that support `Handshake` implicitly support the set of
        /// feature flags previously handled by `Configure` prior to `Handshake`'s introduction, such as secrets and resource
        /// references.
        async fn handshake(
            &self,
            request: tonic::Request<super::ProviderHandshakeRequest>,
        ) -> std::result::Result<tonic::Response<super::ProviderHandshakeResponse>, tonic::Status>;
        /// `Parameterize` is the primary means of supporting [parameterized providers](parameterized-providers), which allow
        /// a caller to change a provider's behavior ahead of its [configuration](pulumirpc.ResourceProvider.Configure) and
        /// subsequent use. Where a [](pulumirpc.ResourceProvider.Configure) call allows a caller to influence provider
        /// behaviour at a high level (e.g. by specifying the region in which an AWS provider should operate), a
        /// `Parameterize` call may change the set of resources and functions that a provider offers (that is, its schema).
        /// This is useful in any case where some "set" of providers can be captured by a single implementation that may
        /// power fundamentally different schemata -- dynamically bridging Terraform providers, or managing Kubernetes
        /// clusters with custom resource definitions, for instance, are good examples. The parameterized package that
        /// `Parameterize` yields is known as a *sub-package* of the original (unparameterized) package.
        ///
        /// `Parameterize` supports two types of parameterization:
        ///
        /// * *Replacement parameterization*, whereby a `Parameterize` call results in a schema that completely replaces the
        ///   original provider schema. Bridging a Terraform provider dynamically might be an example of this -- following
        ///   the call to `Parameterize`, the provider's schema will become that of the Terraform provider that was bridged.
        ///   Providers that implement replacement parameterization expect a *single* call to `Parameterize`.
        ///
        /// * *Extension parameterization*, in which a `Parameterize` call results in a schema that is a superset of the
        ///   original. This is useful in cases where a provider can be extended with additional resources or functions, such
        ///   as a Kubernetes provider that can be extended with resources representing custom resource definitions.
        ///   Providers that implement extension parameterization should accept multiple calls to `Parameterize`. Extension
        ///   packages may even be called multiple times with the same package name, but with different versions. The CRUD
        ///   operations of extension resources must include the version of which sub-package they correspond to.
        ///
        /// `Parameterize` should work the same whether it is provided with `ParametersArgs` or `ParametersValue` input. In
        /// each case it should return the sub-package name and version (which when a `ParametersValue` is supplied should
        /// match the given input).
        async fn parameterize(
            &self,
            request: tonic::Request<super::ParameterizeRequest>,
        ) -> std::result::Result<tonic::Response<super::ParameterizeResponse>, tonic::Status>;
        /// GetSchema fetches the schema for this resource provider.
        async fn get_schema(
            &self,
            request: tonic::Request<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSchemaResponse>, tonic::Status>;
        /// `CheckConfig` validates a set of configuration inputs that will be passed to this provider instance.
        /// `CheckConfig` is to provider resources what [](pulumirpc.ResourceProvider.Check) is to individual resources, and
        /// is the first stage in configuring (that is, eventually executing a [](pulumirpc.ResourceProvider.Configure) call)
        /// a provider using user-supplied values. In the case that provider inputs are coming from some source that has been
        /// checked previously (e.g. a Pulumi state), it is not necessary to call `CheckConfig`.
        ///
        /// A `CheckConfig` call returns either a set of checked, known-valid inputs that may subsequently be passed to
        /// [](pulumirpc.ResourceProvider.DiffConfig) and/or [](pulumirpc.ResourceProvider.Configure), or a set of errors
        /// explaining why the inputs are invalid. In the case that a set of inputs are successfully validated and returned,
        /// `CheckConfig` *may also populate default values* for provider configuration, returning them so that they may be
        /// passed to a subsequent [](pulumirpc.ResourceProvider.Configure) call and persisted in the Pulumi state. In the
        /// case that `CheckConfig` fails and returns a set of errors, it is expected that the caller (typically the Pulumi
        /// engine) will fail provider registration.
        ///
        /// As a rule, the provider inputs returned by a call to `CheckConfig` should preserve the original representation of
        /// the properties as present in the program inputs. Though this rule is not required for correctness, violations
        /// thereof can negatively impact the end-user experience, as the provider inputs are used for detecting and
        /// rendering diffs.
        async fn check_config(
            &self,
            request: tonic::Request<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status>;
        /// `DiffConfig` compares an existing ("old") provider configuration with a new configuration and computes the
        /// difference (if any) between them. `DiffConfig` is to provider resources what [](pulumirpc.ResourceProvider.Diff)
        /// is to individual resources. `DiffConfig` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.CheckConfig) call. The [](pulumirpc.DiffResponse) returned by a `DiffConfig`
        /// call is used primarily to determine whether or not the newly configured provider is capable of managing resources
        /// owned by the old provider. If `DiffConfig` indicates that the provider resource needs to be replaced, for
        /// instance, then all resources owned by that provider will *also* need to be replaced. Replacement semantics should
        /// thus be reserved for changes to configuration properties that are guaranteed to make old resources unmanageable.
        /// Changes to an AWS region, for example, will almost certainly require a provider replacement, but changes to an
        /// AWS access key, should almost certainly not.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        async fn diff_config(
            &self,
            request: tonic::Request<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status>;
        /// `Configure` is the final stage in configuring a provider instance. Callers may supply two sets of data:
        ///
        /// * Provider-specific configuration, which is the set of inputs that have been validated by a previous
        ///   [](pulumirpc.ResourceProvider.CheckConfig) call.
        /// * Provider-agnostic ("protocol") configuration, such as whether or not the caller supports secrets.
        ///
        /// The provider is expected to return its own set of protocol configuration, indicating which features it supports
        /// in turn so that the caller and the provider can interact appropriately.
        ///
        /// Providers may expect a *single* call to `Configure`. If a call to `Configure` is missing required configuration,
        /// the provider may return a set of error details containing [](pulumirpc.ConfigureErrorMissingKeys) values to
        /// indicate which keys are missing.
        ///
        /// :::{important}
        /// The use of `Configure` to configure protocol features is deprecated in favour of the
        /// [](pulumirpc.ResourceProvider.Handshake) method, which should be implemented by newer providers. To enable
        /// compatibility between older engines and providers:
        ///
        /// * Callers which call `Handshake` *must* call `Configure` with flags such as `acceptSecrets` and `acceptResources`
        ///   set to `true`, since these features predate the introduction of `Handshake` and thus `Handshake`-aware callers
        ///   must support them. See [](pulumirpc.ConfigureRequest) for more information.
        /// * Providers which implement `Handshake` *must* support flags such as `acceptSecrets` and `acceptResources`, and
        ///   indicate as such by always returning `true` for these fields in [](pulumirpc.ConfigureResponse). See
        ///   [](pulumirpc.ConfigureResponse) for more information.
        /// :::
        async fn configure(
            &self,
            request: tonic::Request<super::ConfigureRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigureResponse>, tonic::Status>;
        /// Invoke dynamically executes a built-in function in the provider.
        async fn invoke(
            &self,
            request: tonic::Request<super::InvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status>;
        /// Server streaming response type for the StreamInvoke method.
        type StreamInvokeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::InvokeResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// StreamInvoke dynamically executes a built-in function in the provider, which returns a stream
        /// of responses.
        async fn stream_invoke(
            &self,
            request: tonic::Request<super::InvokeRequest>,
        ) -> std::result::Result<tonic::Response<Self::StreamInvokeStream>, tonic::Status>;
        /// Call dynamically executes a method in the provider associated with a component resource.
        async fn call(
            &self,
            request: tonic::Request<super::CallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status>;
        /// `Check` validates a set of input properties against a given resource type. A `Check` call returns either a set of
        /// checked, known-valid inputs that may subsequently be passed to [](pulumirpc.ResourceProvider.Diff),
        /// [](pulumirpc.ResourceProvider.Create), or [](pulumirpc.ResourceProvider.Update); or a set of errors explaining
        /// why the inputs are invalid. In the case that a set of inputs are successfully validated and returned, `Check`
        /// *may also populate default values* for resource inputs, returning them so that they may be passed to a subsequent
        /// call and persisted in the Pulumi state. In the case that `Check` fails and returns a set of errors, it is
        /// expected that the caller (typically the Pulumi engine) will fail resource registration.
        ///
        /// As a rule, the provider inputs returned by a call to `Check` should preserve the original representation of the
        /// properties as present in the program inputs. Though this rule is not required for correctness, violations thereof
        /// can negatively impact the end-user experience, as the provider inputs are used for detecting and rendering
        /// diffs.
        async fn check(
            &self,
            request: tonic::Request<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status>;
        /// `Diff` compares an existing ("old") set of resource properties with a new set of properties and computes the
        /// difference (if any) between them. `Diff` should only be called with values that have at some point been validated
        /// by a [](pulumirpc.ResourceProvider.Check) call.
        ///
        /// Implementations must satisfy the invariants documented on `DiffResponse`.
        async fn diff(
            &self,
            request: tonic::Request<super::DiffRequest>,
        ) -> std::result::Result<tonic::Response<super::DiffResponse>, tonic::Status>;
        /// `Create` provisions a new instance of the specified [(custom) resource](custom-resources). It returns a
        /// provider-assigned ID for the resource as well as the output properties that arose from the creation properties.
        /// Output properties are typically the union of the resource's input properties and any additional values that were
        /// computed or made available during creation.
        ///
        /// If creation fails, `Create` may return an [](pulumirpc.ErrorResourceInitFailed) error detail explaining why.
        /// Moreover, if `Create` does return an error, it must be the case that the resource was *not* created (that is,
        /// `Create` can be thought of as transactional or atomic).
        async fn create(
            &self,
            request: tonic::Request<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status>;
        /// `Read` reads the current live state associated with a resource identified by the supplied state. The given state
        /// must be sufficient to uniquely identify the resource. This is typically just the resource ID, but may also
        /// include other properties.
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status>;
        /// `Update` updates an existing resource according to a new set of inputs, returning a new set of output properties.
        async fn update(
            &self,
            request: tonic::Request<super::UpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateResponse>, tonic::Status>;
        /// `Delete` deprovisions an existing resource as specified by its ID. `Delete` should be transactional/atomic -- if
        /// a call to `Delete` fails, it must be the case that the resource was *not* deleted and can be assumed to still
        /// exist.
        async fn delete(
            &self,
            request: tonic::Request<super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// `Construct` provisions a new [component resource](component-resources). Providers that implement `Construct` are
        /// referred to as [component providers](component-providers). `Construct` is to component resources what
        /// [](pulumirpc.ResourceProvider.Create) is to [custom resources](custom-resources). Components do not have any
        /// lifecycle of their own, and instead embody the lifecycles of the resources that they are composed of. As such,
        /// `Construct` is effectively a subprogram whose resources will be persisted in the caller's state. It is
        /// consequently passed enough information to manage fully these resources. At a high level, this comprises:
        ///
        /// * A [](pulumirpc.ResourceMonitor) endpoint which the provider can use to [register](resource-registration) nested
        ///   custom or component resources that belong to the component.
        ///
        /// * A set of input properties.
        ///
        /// * A full set of [resource options](https://www.pulumi.com/docs/iac/concepts/options/) that the component should
        ///   propagate to resources it registers against the supplied resource monitor.
        async fn construct(
            &self,
            request: tonic::Request<super::ConstructRequest>,
        ) -> std::result::Result<tonic::Response<super::ConstructResponse>, tonic::Status>;
        /// Cancel signals the provider to gracefully shut down and abort any ongoing resource operations.
        /// Operations aborted in this way will return an error (e.g., `Update` and `Create` will either return a
        /// creation error or an initialization error). Since Cancel is advisory and non-blocking, it is up
        /// to the host to decide how long to wait after Cancel is called before (e.g.)
        /// hard-closing any gRPC connection.
        async fn cancel(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// GetPluginInfo returns generic information about this plugin, like its version.
        async fn get_plugin_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::PluginInfo>, tonic::Status>;
        /// Attach sends the engine address to an already running plugin.
        async fn attach(
            &self,
            request: tonic::Request<super::PluginAttach>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// GetMapping fetches the mapping for this resource provider, if any. A provider should return an empty
        /// response (not an error) if it doesn't have a mapping for the given key.
        async fn get_mapping(
            &self,
            request: tonic::Request<super::GetMappingRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMappingResponse>, tonic::Status>;
        /// GetMappings is an optional method that returns what mappings (if any) a provider supports. If a provider does not
        /// implement this method the engine falls back to the old behaviour of just calling GetMapping without a name.
        /// If this method is implemented than the engine will then call GetMapping only with the names returned from this method.
        async fn get_mappings(
            &self,
            request: tonic::Request<super::GetMappingsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMappingsResponse>, tonic::Status>;
    }
    /// The ResourceProvider service defines a standard interface for [resource providers](providers). A resource provider
    /// manages a set of configuration, resources, functions and so on in a single package, and offers methods such as CRUD
    /// operations on resources and invocations of functions. Resource providers are primarily managed by the Pulumi engine
    /// as part of a deployment in order to interact with the cloud providers underpinning a Pulumi application.
    #[derive(Debug)]
    pub struct ResourceProviderServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ResourceProviderServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ResourceProviderServer<T>
    where
        T: ResourceProvider,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.ResourceProvider/Handshake" => {
                    #[allow(non_camel_case_types)]
                    struct HandshakeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider>
                        tonic::server::UnaryService<super::ProviderHandshakeRequest>
                        for HandshakeSvc<T>
                    {
                        type Response = super::ProviderHandshakeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProviderHandshakeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::handshake(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HandshakeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Parameterize" => {
                    #[allow(non_camel_case_types)]
                    struct ParameterizeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider>
                        tonic::server::UnaryService<super::ParameterizeRequest>
                        for ParameterizeSvc<T>
                    {
                        type Response = super::ParameterizeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ParameterizeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::parameterize(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ParameterizeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetSchemaSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::GetSchemaRequest> for GetSchemaSvc<T> {
                        type Response = super::GetSchemaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSchemaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/CheckConfig" => {
                    #[allow(non_camel_case_types)]
                    struct CheckConfigSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::CheckRequest> for CheckConfigSvc<T> {
                        type Response = super::CheckResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::check_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/DiffConfig" => {
                    #[allow(non_camel_case_types)]
                    struct DiffConfigSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::DiffRequest> for DiffConfigSvc<T> {
                        type Response = super::DiffResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DiffRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::diff_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiffConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Configure" => {
                    #[allow(non_camel_case_types)]
                    struct ConfigureSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::ConfigureRequest> for ConfigureSvc<T> {
                        type Response = super::ConfigureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConfigureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::configure(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConfigureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::InvokeRequest> for InvokeSvc<T> {
                        type Response = super::InvokeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/StreamInvoke" => {
                    #[allow(non_camel_case_types)]
                    struct StreamInvokeSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider>
                        tonic::server::ServerStreamingService<super::InvokeRequest>
                        for StreamInvokeSvc<T>
                    {
                        type Response = super::InvokeResponse;
                        type ResponseStream = T::StreamInvokeStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::stream_invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamInvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Call" => {
                    #[allow(non_camel_case_types)]
                    struct CallSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::CallRequest> for CallSvc<T> {
                        type Response = super::CallResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ResourceProvider>::call(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Check" => {
                    #[allow(non_camel_case_types)]
                    struct CheckSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::CheckRequest> for CheckSvc<T> {
                        type Response = super::CheckResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Diff" => {
                    #[allow(non_camel_case_types)]
                    struct DiffSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::DiffRequest> for DiffSvc<T> {
                        type Response = super::DiffResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DiffRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ResourceProvider>::diff(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiffSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Create" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::CreateRequest> for CreateSvc<T> {
                        type Response = super::CreateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::create(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::ReadRequest> for ReadSvc<T> {
                        type Response = super::ReadResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ResourceProvider>::read(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Update" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::UpdateRequest> for UpdateSvc<T> {
                        type Response = super::UpdateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::update(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Delete" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::DeleteRequest> for DeleteSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Construct" => {
                    #[allow(non_camel_case_types)]
                    struct ConstructSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::ConstructRequest> for ConstructSvc<T> {
                        type Response = super::ConstructResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConstructRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::construct(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConstructSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<()> for CancelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetPluginInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetPluginInfoSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<()> for GetPluginInfoSvc<T> {
                        type Response = super::PluginInfo;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_plugin_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPluginInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/Attach" => {
                    #[allow(non_camel_case_types)]
                    struct AttachSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::PluginAttach> for AttachSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PluginAttach>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::attach(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AttachSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetMapping" => {
                    #[allow(non_camel_case_types)]
                    struct GetMappingSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::GetMappingRequest>
                        for GetMappingSvc<T>
                    {
                        type Response = super::GetMappingResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMappingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_mapping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMappingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceProvider/GetMappings" => {
                    #[allow(non_camel_case_types)]
                    struct GetMappingsSvc<T: ResourceProvider>(pub Arc<T>);
                    impl<T: ResourceProvider> tonic::server::UnaryService<super::GetMappingsRequest>
                        for GetMappingsSvc<T>
                    {
                        type Response = super::GetMappingsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMappingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceProvider>::get_mappings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMappingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(empty_body());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for ResourceProviderServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.ResourceProvider";
    impl<T> tonic::server::NamedService for ResourceProviderServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alias {
    #[prost(oneof = "alias::Alias", tags = "1, 2")]
    pub alias: ::core::option::Option<alias::Alias>,
}
/// Nested message and enum types in `Alias`.
pub mod alias {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Spec {
        /// The previous name of the resource.  If none is provided, we will use the current name.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The previous type of the resource. If none is provided, we will use the current resoource type.
        #[prost(string, tag = "2")]
        pub r#type: ::prost::alloc::string::String,
        /// The previous stack of the resource. If not set, the current stack of the resource is used.
        #[prost(string, tag = "3")]
        pub stack: ::prost::alloc::string::String,
        /// The previous project of the resource. If not set, the current project of the resource is used.
        #[prost(string, tag = "4")]
        pub project: ::prost::alloc::string::String,
        /// The previous parent of the resource. If not set, the current parent of the resource is used.
        #[prost(oneof = "spec::Parent", tags = "5, 6")]
        pub parent: ::core::option::Option<spec::Parent>,
    }
    /// Nested message and enum types in `Spec`.
    pub mod spec {
        /// The previous parent of the resource. If not set, the current parent of the resource is used.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Parent {
            /// The urn of the previous parent.
            #[prost(string, tag = "5")]
            ParentUrn(::prost::alloc::string::String),
            /// Used to indicate the resource previously had no parent. If false this property is ignored.
            #[prost(bool, tag = "6")]
            NoParent(bool),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Alias {
        /// The previous urn to alias to.
        #[prost(string, tag = "1")]
        Urn(::prost::alloc::string::String),
        /// An alias specification.
        #[prost(message, tag = "2")]
        Spec(Spec),
    }
}
/// A SourcePosition represents a position in a source file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourcePosition {
    /// The URI of the file. Currently only the file scheme with an absolute path is supported.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The line in the file
    #[prost(int32, tag = "2")]
    pub line: i32,
    /// The column in the line
    #[prost(int32, tag = "3")]
    pub column: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callback {
    /// the gRPC target of the callback service.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// the service specific unique token for this callback.
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallbackInvokeRequest {
    /// the token for the callback.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// the serialized protobuf message of the arguments for this callback.
    #[prost(bytes = "vec", tag = "2")]
    pub request: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallbackInvokeResponse {
    /// the serialized protobuf message of the response for this callback.
    #[prost(bytes = "vec", tag = "1")]
    pub response: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod callbacks_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Callbacks is a service for invoking functions in one runtime from other processes.
    #[derive(Debug, Clone)]
    pub struct CallbacksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CallbacksClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CallbacksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CallbacksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CallbacksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Invoke invokes a given callback, identified by its token.
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::CallbackInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::CallbackInvokeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.Callbacks/Invoke");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.Callbacks", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod callbacks_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CallbacksServer.
    #[async_trait]
    pub trait Callbacks: std::marker::Send + std::marker::Sync + 'static {
        /// Invoke invokes a given callback, identified by its token.
        async fn invoke(
            &self,
            request: tonic::Request<super::CallbackInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::CallbackInvokeResponse>, tonic::Status>;
    }
    /// Callbacks is a service for invoking functions in one runtime from other processes.
    #[derive(Debug)]
    pub struct CallbacksServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CallbacksServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CallbacksServer<T>
    where
        T: Callbacks,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.Callbacks/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: Callbacks>(pub Arc<T>);
                    impl<T: Callbacks> tonic::server::UnaryService<super::CallbackInvokeRequest> for InvokeSvc<T> {
                        type Response = super::CallbackInvokeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CallbackInvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Callbacks>::invoke(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(empty_body());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for CallbacksServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.Callbacks";
    impl<T> tonic::server::NamedService for CallbacksServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// SupportsFeatureRequest allows a client to test if the resource monitor supports a certain feature, which it may use
/// to control the format or types of messages it sends.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupportsFeatureRequest {
    /// the ID of the feature to test support for.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SupportsFeatureResponse {
    /// true when the resource monitor supports this feature.
    #[prost(bool, tag = "1")]
    pub has_support: bool,
}
/// ReadResourceRequest contains enough information to uniquely qualify and read a resource's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResourceRequest {
    /// the ID of the resource to read.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// the type of the resource object.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// the name, for URN purposes, of the object.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// optional state sufficient to uniquely identify the resource.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// a list of URNs that this read depends on, as observed by the language host.
    #[prost(string, repeated, tag = "6")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// an optional reference to the provider to use for this read.
    #[prost(string, tag = "7")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
    /// when true operations should return secrets as strongly typed.
    #[prost(bool, tag = "9")]
    pub accept_secrets: bool,
    /// a list of output properties that should also be treated as secret, in addition to ones we detect.
    #[prost(string, repeated, tag = "10")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "12")]
    pub accept_resources: bool,
    /// the server url of the provider to use when servicing this request.
    #[prost(string, tag = "13")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums of the provider to use when servicing this request.
    #[prost(map = "string, bytes", tag = "15")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// the optional source position of the user code that initiated the read.
    #[prost(message, optional, tag = "14")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// a reference from RegisterProviderRequest.
    #[prost(string, tag = "16")]
    pub package_ref: ::prost::alloc::string::String,
}
/// ReadResourceResponse contains the result of reading a resource's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResourceResponse {
    /// the URN for this resource.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the state of the resource read from the live environment.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
}
/// RegisterResourceRequest contains information about a resource object that was newly allocated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceRequest {
    /// the type of the object allocated.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the name, for URN purposes, of the object.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// an optional parent URN that this child resource belongs to.
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    /// true if the resource is a custom, managed by a plugin's CRUD operations.
    #[prost(bool, tag = "4")]
    pub custom: bool,
    /// an object produced by the interpreter/source.
    #[prost(message, optional, tag = "5")]
    pub object: ::core::option::Option<::prost_types::Struct>,
    /// true if the resource should be marked protected.
    #[prost(bool, tag = "6")]
    pub protect: bool,
    /// a list of URNs that this resource depends on, as observed by the language host.
    #[prost(string, repeated, tag = "7")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// an optional reference to the provider to manage this resource's CRUD operations.
    #[prost(string, tag = "8")]
    pub provider: ::prost::alloc::string::String,
    /// a map from property keys to the dependencies of the property.
    #[prost(map = "string, message", tag = "9")]
    pub property_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        register_resource_request::PropertyDependencies,
    >,
    /// true if this resource should be deleted before replacement.
    #[prost(bool, tag = "10")]
    pub delete_before_replace: bool,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "11")]
    pub version: ::prost::alloc::string::String,
    /// a list of property selectors to ignore during updates.
    #[prost(string, repeated, tag = "12")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// when true operations should return secrets as strongly typed.
    #[prost(bool, tag = "13")]
    pub accept_secrets: bool,
    /// a list of output properties that should also be treated as secret, in addition to ones we detect.
    #[prost(string, repeated, tag = "14")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a list of additional URNs that should be considered the same.
    #[prost(string, repeated, tag = "15")]
    pub alias_ur_ns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// if set, this resource's state should be imported from the given ID.
    #[prost(string, tag = "16")]
    pub import_id: ::prost::alloc::string::String,
    /// ability to pass a custom Timeout block.
    #[prost(message, optional, tag = "17")]
    pub custom_timeouts: ::core::option::Option<register_resource_request::CustomTimeouts>,
    /// true if the deleteBeforeReplace property should be treated as defined even if it is false.
    #[prost(bool, tag = "18")]
    pub delete_before_replace_defined: bool,
    /// true if the request is from an SDK that supports partially-known properties during preview.
    #[prost(bool, tag = "19")]
    pub supports_partial_values: bool,
    /// true if the resource is a plugin-managed component resource.
    #[prost(bool, tag = "20")]
    pub remote: bool,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "21")]
    pub accept_resources: bool,
    /// an optional reference to the provider map to manage this resource's CRUD operations.
    #[prost(map = "string, string", tag = "22")]
    pub providers:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// a list of properties that if changed should force a replacement.
    #[prost(string, repeated, tag = "23")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the server URL of the provider to use when servicing this request.
    #[prost(string, tag = "24")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums expected for the provider plugin.
    #[prost(map = "string, bytes", tag = "30")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// if true the engine will not call the resource providers delete method for this resource.
    #[prost(bool, tag = "25")]
    pub retain_on_delete: bool,
    /// a list of additional aliases that should be considered the same.
    #[prost(message, repeated, tag = "26")]
    pub aliases: ::prost::alloc::vec::Vec<Alias>,
    /// if set the engine will not call the resource providers delete method for this resource when specified resource is deleted.
    #[prost(string, tag = "27")]
    pub deleted_with: ::prost::alloc::string::String,
    /// Indicates that alias specs are specified correctly according to the spec.
    /// Older versions of the Node.js SDK did not send alias specs correctly.
    /// If this is not set to true and the engine detects the request is from the
    /// Node.js runtime, the engine will transform incorrect alias specs into
    /// correct ones.
    /// Other SDKs that are correctly specifying alias specs could set this to
    /// true, but it's not necessary.
    #[prost(bool, tag = "28")]
    pub alias_specs: bool,
    /// the optional source position of the user code that initiated the register.
    #[prost(message, optional, tag = "29")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// a list of transforms to apply to the resource before registering it.
    #[prost(message, repeated, tag = "31")]
    pub transforms: ::prost::alloc::vec::Vec<Callback>,
    /// true if the request is from an SDK that supports the result field in the response.
    #[prost(bool, tag = "32")]
    pub supports_result_reporting: bool,
    /// a reference from RegisterProviderRequest.
    #[prost(string, tag = "33")]
    pub package_ref: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RegisterResourceRequest`.
pub mod register_resource_request {
    /// PropertyDependencies describes the resources that a particular property depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// CustomTimeouts allows a user to be able to create a set of custom timeout parameters.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomTimeouts {
        /// The create resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "1")]
        pub create: ::prost::alloc::string::String,
        /// The update resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "2")]
        pub update: ::prost::alloc::string::String,
        /// The delete resource timeout represented as a string e.g. 5m.
        #[prost(string, tag = "3")]
        pub delete: ::prost::alloc::string::String,
    }
}
/// RegisterResourceResponse is returned by the engine after a resource has finished being initialized.  It includes the
/// auto-assigned URN, the provider-assigned ID, and any other properties initialized by the engine.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceResponse {
    /// the URN assigned by the engine.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// the unique ID assigned by the provider.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// the resulting object properties, including provider defaults.
    #[prost(message, optional, tag = "3")]
    pub object: ::core::option::Option<::prost_types::Struct>,
    /// if true, the object's state is stable and may be trusted not to change.
    #[prost(bool, tag = "4")]
    pub stable: bool,
    /// an optional list of guaranteed-stable properties.
    #[prost(string, repeated, tag = "5")]
    pub stables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// a map from property keys to the dependencies of the property.
    #[prost(map = "string, message", tag = "6")]
    pub property_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        register_resource_response::PropertyDependencies,
    >,
    /// the reason, whether the resource registration was successful, failed, or skipped.
    #[prost(enumeration = "Result", tag = "7")]
    pub result: i32,
}
/// Nested message and enum types in `RegisterResourceResponse`.
pub mod register_resource_response {
    /// PropertyDependencies describes the resources that a particular property depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropertyDependencies {
        /// A list of URNs this property depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// RegisterResourceOutputsRequest adds extra resource outputs created by the program after registration has occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResourceOutputsRequest {
    /// the URN for the resource to attach output properties to.
    #[prost(string, tag = "1")]
    pub urn: ::prost::alloc::string::String,
    /// additional output properties to add to the existing resource.
    #[prost(message, optional, tag = "2")]
    pub outputs: ::core::option::Option<::prost_types::Struct>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceInvokeRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// an optional reference to the provider version to use for this invoke.
    #[prost(string, tag = "3")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// when true operations should return resource references as strongly typed.
    #[prost(bool, tag = "5")]
    pub accept_resources: bool,
    /// an optional reference to the provider url to use for this invoke.
    #[prost(string, tag = "6")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums expected for the provider plugin.
    #[prost(map = "string, bytes", tag = "8")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// the optional source position of the user code that initiated the invoke.
    #[prost(message, optional, tag = "7")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// a reference from RegisterProviderRequest.
    #[prost(string, tag = "9")]
    pub package_ref: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCallRequest {
    /// the function token to invoke.
    #[prost(string, tag = "1")]
    pub tok: ::prost::alloc::string::String,
    /// the arguments for the function invocation.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// a map from argument keys to the dependencies of the argument.
    #[prost(map = "string, message", tag = "3")]
    pub arg_dependencies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        resource_call_request::ArgumentDependencies,
    >,
    /// an optional reference to the provider to use for this invoke.
    #[prost(string, tag = "4")]
    pub provider: ::prost::alloc::string::String,
    /// the version of the provider to use when servicing this request.
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    /// the pluginDownloadURL of the provider to use when servicing this request.
    #[prost(string, tag = "13")]
    pub plugin_download_url: ::prost::alloc::string::String,
    /// a map of checksums of the provider to use when servicing this request.
    #[prost(map = "string, bytes", tag = "16")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// the optional source position of the user code that initiated the call.
    #[prost(message, optional, tag = "15")]
    pub source_position: ::core::option::Option<SourcePosition>,
    /// a reference from RegisterProviderRequest.
    #[prost(string, tag = "17")]
    pub package_ref: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ResourceCallRequest`.
pub mod resource_call_request {
    /// ArgumentDependencies describes the resources that a particular argument depends on.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArgumentDependencies {
        /// A list of URNs this argument depends on.
        #[prost(string, repeated, tag = "1")]
        pub urns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// TransformResourceOptions is a subset of all resource options that are relevant to transforms.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformResourceOptions {
    #[prost(string, repeated, tag = "1")]
    pub depends_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub protect: bool,
    #[prost(string, repeated, tag = "3")]
    pub ignore_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub replace_on_changes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub aliases: ::prost::alloc::vec::Vec<Alias>,
    #[prost(string, tag = "7")]
    pub provider: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub custom_timeouts: ::core::option::Option<register_resource_request::CustomTimeouts>,
    #[prost(string, tag = "9")]
    pub plugin_download_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub retain_on_delete: bool,
    #[prost(string, tag = "11")]
    pub deleted_with: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "12")]
    pub delete_before_replace: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "13")]
    pub additional_secret_outputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "14")]
    pub providers:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(map = "string, bytes", tag = "15")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformRequest {
    /// the type of the resource.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// the name of the resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// true if the resource is a custom resource, else it's a component resource.
    #[prost(bool, tag = "3")]
    pub custom: bool,
    /// the parent of the resource, this can't be changed by the transform.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// the input properties of the resource.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "6")]
    pub options: ::core::option::Option<TransformResourceOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformResponse {
    /// the transformed input properties.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransformResourceOptions>,
}
/// TransformInvokeRequest is the request object for the TransformInvoke RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeRequest {
    /// the token for the invoke request.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// the input args of the resource.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<TransformInvokeOptions>,
}
/// TransformInvokeResponse is the response object for the TransformInvoke RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeResponse {
    /// the transformed input args.
    #[prost(message, optional, tag = "1")]
    pub args: ::core::option::Option<::prost_types::Struct>,
    /// the options for the resource.
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<TransformInvokeOptions>,
}
/// TransformInvokeOptions is a subset of all invoke options that are relevant to transforms.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformInvokeOptions {
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub plugin_download_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(map = "string, bytes", tag = "4")]
    pub plugin_checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterPackageRequest {
    /// the plugin name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the plugin version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the optional plugin download url.
    #[prost(string, tag = "3")]
    pub download_url: ::prost::alloc::string::String,
    /// the optional plugin checksums.
    #[prost(map = "string, bytes", tag = "4")]
    pub checksums:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// the optional parameterization for this package.
    #[prost(message, optional, tag = "5")]
    pub parameterization: ::core::option::Option<Parameterization>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterPackageResponse {
    /// The UUID package reference for this registered package.
    #[prost(string, tag = "1")]
    pub r#ref: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameterization {
    /// the parameterized package name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the parameterized package version.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the parameter value for the parameterized package.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Result {
    Success = 0,
    Fail = 1,
    Skip = 2,
}
impl Result {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Success => "SUCCESS",
            Self::Fail => "FAIL",
            Self::Skip => "SKIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUCCESS" => Some(Self::Success),
            "FAIL" => Some(Self::Fail),
            "SKIP" => Some(Self::Skip),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod resource_monitor_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// ResourceMonitor is the interface a source uses to talk back to the planning monitor orchestrating the execution.
    #[derive(Debug, Clone)]
    pub struct ResourceMonitorClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ResourceMonitorClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ResourceMonitorClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResourceMonitorClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ResourceMonitorClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn supports_feature(
            &mut self,
            request: impl tonic::IntoRequest<super::SupportsFeatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SupportsFeatureResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/SupportsFeature");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "SupportsFeature",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::ResourceInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/Invoke");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "Invoke"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stream_invoke(
            &mut self,
            request: impl tonic::IntoRequest<super::ResourceInvokeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InvokeResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/StreamInvoke");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "StreamInvoke"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn call(
            &mut self,
            request: impl tonic::IntoRequest<super::ResourceCallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/Call");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "Call"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResourceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/ReadResource");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pulumirpc.ResourceMonitor", "ReadResource"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterResourceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/RegisterResource");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "RegisterResource",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_resource_outputs(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterResourceOutputsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterResourceOutputs",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "RegisterResourceOutputs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Register a resource transform for the stack
        pub async fn register_stack_transform(
            &mut self,
            request: impl tonic::IntoRequest<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterStackTransform",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "RegisterStackTransform",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Register an invoke transform for the stack
        pub async fn register_stack_invoke_transform(
            &mut self,
            request: impl tonic::IntoRequest<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pulumirpc.ResourceMonitor/RegisterStackInvokeTransform",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "RegisterStackInvokeTransform",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_package(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterPackageRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterPackageResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/pulumirpc.ResourceMonitor/RegisterPackage");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "pulumirpc.ResourceMonitor",
                "RegisterPackage",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod resource_monitor_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ResourceMonitorServer.
    #[async_trait]
    pub trait ResourceMonitor: std::marker::Send + std::marker::Sync + 'static {
        async fn supports_feature(
            &self,
            request: tonic::Request<super::SupportsFeatureRequest>,
        ) -> std::result::Result<tonic::Response<super::SupportsFeatureResponse>, tonic::Status>;
        async fn invoke(
            &self,
            request: tonic::Request<super::ResourceInvokeRequest>,
        ) -> std::result::Result<tonic::Response<super::InvokeResponse>, tonic::Status>;
        /// Server streaming response type for the StreamInvoke method.
        type StreamInvokeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::InvokeResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn stream_invoke(
            &self,
            request: tonic::Request<super::ResourceInvokeRequest>,
        ) -> std::result::Result<tonic::Response<Self::StreamInvokeStream>, tonic::Status>;
        async fn call(
            &self,
            request: tonic::Request<super::ResourceCallRequest>,
        ) -> std::result::Result<tonic::Response<super::CallResponse>, tonic::Status>;
        async fn read_resource(
            &self,
            request: tonic::Request<super::ReadResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResourceResponse>, tonic::Status>;
        async fn register_resource(
            &self,
            request: tonic::Request<super::RegisterResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterResourceResponse>, tonic::Status>;
        async fn register_resource_outputs(
            &self,
            request: tonic::Request<super::RegisterResourceOutputsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register a resource transform for the stack
        async fn register_stack_transform(
            &self,
            request: tonic::Request<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register an invoke transform for the stack
        async fn register_stack_invoke_transform(
            &self,
            request: tonic::Request<super::Callback>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn register_package(
            &self,
            request: tonic::Request<super::RegisterPackageRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterPackageResponse>, tonic::Status>;
    }
    /// ResourceMonitor is the interface a source uses to talk back to the planning monitor orchestrating the execution.
    #[derive(Debug)]
    pub struct ResourceMonitorServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ResourceMonitorServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ResourceMonitorServer<T>
    where
        T: ResourceMonitor,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/pulumirpc.ResourceMonitor/SupportsFeature" => {
                    #[allow(non_camel_case_types)]
                    struct SupportsFeatureSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::UnaryService<super::SupportsFeatureRequest>
                        for SupportsFeatureSvc<T>
                    {
                        type Response = super::SupportsFeatureResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SupportsFeatureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::supports_feature(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SupportsFeatureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/Invoke" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::UnaryService<super::ResourceInvokeRequest> for InvokeSvc<T>
                    {
                        type Response = super::InvokeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResourceInvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/StreamInvoke" => {
                    #[allow(non_camel_case_types)]
                    struct StreamInvokeSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::ServerStreamingService<super::ResourceInvokeRequest>
                        for StreamInvokeSvc<T>
                    {
                        type Response = super::InvokeResponse;
                        type ResponseStream = T::StreamInvokeStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResourceInvokeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::stream_invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamInvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/Call" => {
                    #[allow(non_camel_case_types)]
                    struct CallSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::ResourceCallRequest> for CallSvc<T> {
                        type Response = super::CallResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResourceCallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as ResourceMonitor>::call(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/ReadResource" => {
                    #[allow(non_camel_case_types)]
                    struct ReadResourceSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::ReadResourceRequest>
                        for ReadResourceSvc<T>
                    {
                        type Response = super::ReadResourceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::read_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterResource" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterResourceSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::UnaryService<super::RegisterResourceRequest>
                        for RegisterResourceSvc<T>
                    {
                        type Response = super::RegisterResourceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterResourceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_resource(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterResourceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterResourceOutputs" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterResourceOutputsSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::UnaryService<super::RegisterResourceOutputsRequest>
                        for RegisterResourceOutputsSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterResourceOutputsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_resource_outputs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterResourceOutputsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterStackTransform" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterStackTransformSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::Callback>
                        for RegisterStackTransformSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Callback>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_stack_transform(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterStackTransformSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterStackInvokeTransform" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterStackInvokeTransformSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor> tonic::server::UnaryService<super::Callback>
                        for RegisterStackInvokeTransformSvc<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Callback>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_stack_invoke_transform(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterStackInvokeTransformSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/pulumirpc.ResourceMonitor/RegisterPackage" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterPackageSvc<T: ResourceMonitor>(pub Arc<T>);
                    impl<T: ResourceMonitor>
                        tonic::server::UnaryService<super::RegisterPackageRequest>
                        for RegisterPackageSvc<T>
                    {
                        type Response = super::RegisterPackageResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterPackageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ResourceMonitor>::register_package(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterPackageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(empty_body());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for ResourceMonitorServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "pulumirpc.ResourceMonitor";
    impl<T> tonic::server::NamedService for ResourceMonitorServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
