pub mod random_bytes {
    //! The resource `random.RandomBytes` generates random bytes that are intended to be used as a secret, or key. Use this in preference to `random.RandomId` when the output is considered sensitive, and should not be displayed in the CLI.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   jwtSecretRandomBytes:
    //!     type: random:RandomBytes
    //!     properties:
    //!       length: 64
    //!   jwtSecretSecret:
    //!     type: azure:keyvault:Secret
    //!     properties:
    //!       keyVaultId: some-azure-key-vault-id
    //!       value: ${jwtSecretRandomBytes.base64}
    //! ```
    //!
    //! ## Import
    //!
    //! Random bytes can be imported by specifying the value as base64 string.
    //!
    //! ```sh
    //!  $ pulumi import random:index/randomBytes:RandomBytes basic "8/fu3q+2DcgSJ19i0jZ5Cw=="
    //! ```
    //!
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomBytesArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The number of bytes requested. The minimum value for length is 1.
        #[builder(into)]
        pub length: pulumi_wasm_rust::Output<i32>,
    }
    #[allow(dead_code)]
    pub struct RandomBytesResult {
        /// The generated bytes presented in base64 string format.
        pub base64: pulumi_wasm_rust::Output<String>,
        /// The generated bytes presented in hex string format.
        pub hex: pulumi_wasm_rust::Output<String>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The number of bytes requested. The minimum value for length is 1.
        pub length: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomBytesArgs) -> RandomBytesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let length_binding = args.length.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomBytes:RandomBytes".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "length".into(),
                    value: &length_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "base64".into(),
                },
                register_interface::ResultField {
                    name: "hex".into(),
                },
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "length".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomBytesResult {
            base64: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("base64").unwrap(),
            ),
            hex: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hex").unwrap(),
            ),
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            length: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("length").unwrap(),
            ),
        }
    }
}
pub mod random_id {
    //! The resource `random.RandomId` generates random numbers that are intended to be
    //! used as unique identifiers for other resources. If the output is considered
    //! sensitive, and should not be displayed in the CLI, use `random.RandomBytes`
    //! instead.
    //!
    //! This resource *does* use a cryptographic random number generator in order
    //! to minimize the chance of collisions, making the results of this resource
    //! when a 16-byte identifier is requested of equivalent uniqueness to a
    //! type-4 UUID.
    //!
    //! This resource can be used in conjunction with resources that have
    //! the `create_before_destroy` lifecycle flag set to avoid conflicts with
    //! unique names during the brief period where both the old and new resources
    //! exist concurrently.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   # The following example shows how to generate a unique name for an AWS EC2
    //!   # instance that changes each time a new AMI id is selected.
    //!   serverRandomId:
    //!     type: random:RandomId
    //!     properties:
    //!       keepers:
    //!         ami_id: ${var.ami_id}
    //!       byteLength: 8
    //!   serverInstance:
    //!     type: aws:ec2:Instance
    //!     properties:
    //!       tags:
    //!         Name: web-server ${serverRandomId.hex}
    //!       # Read the AMI id "through" the random_id resource to ensure that
    //!       #   # both will change together.
    //!       ami: ${serverRandomId.keepers.amiId}
    //! ```
    //!
    //! ## Import
    //!
    //! Random IDs can be imported using the b64_url with an optional prefix. This can be used to replace a config value with a value interpolated from the random provider without experiencing diffs. Example with no prefix
    //!
    //! ```sh
    //!  $ pulumi import random:index/randomId:RandomId server p-9hUg
    //! ```
    //!
    //!  Example with prefix (prefix is separated by a ,)
    //!
    //! ```sh
    //!  $ pulumi import random:index/randomId:RandomId server my-prefix-,p-9hUg
    //! ```
    //!
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomIdArgs {
        /// The number of random bytes to produce. The minimum value is 1, which produces eight bits of randomness.
        #[builder(into)]
        pub byte_length: pulumi_wasm_rust::Output<i32>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// Arbitrary string to prefix the output value with. This string is supplied as-is, meaning it is not guaranteed to be URL-safe or base64 encoded.
        #[builder(into, default)]
        pub prefix: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct RandomIdResult {
        /// The generated id presented in base64 without additional transformations.
        pub b64_std: pulumi_wasm_rust::Output<String>,
        /// The generated id presented in base64, using the URL-friendly character set: case-sensitive letters, digits and the characters `_` and `-`.
        pub b64_url: pulumi_wasm_rust::Output<String>,
        /// The number of random bytes to produce. The minimum value is 1, which produces eight bits of randomness.
        pub byte_length: pulumi_wasm_rust::Output<i32>,
        /// The generated id presented in non-padded decimal digits.
        pub dec: pulumi_wasm_rust::Output<String>,
        /// The generated id presented in padded hexadecimal digits. This result will always be twice as long as the requested byte length.
        pub hex: pulumi_wasm_rust::Output<String>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// Arbitrary string to prefix the output value with. This string is supplied as-is, meaning it is not guaranteed to be URL-safe or base64 encoded.
        pub prefix: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomIdArgs) -> RandomIdResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let byte_length_binding = args.byte_length.get_inner();
        let keepers_binding = args.keepers.get_inner();
        let prefix_binding = args.prefix.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomId:RandomId".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "byteLength".into(),
                    value: &byte_length_binding,
                },
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "prefix".into(),
                    value: &prefix_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "b64Std".into(),
                },
                register_interface::ResultField {
                    name: "b64Url".into(),
                },
                register_interface::ResultField {
                    name: "byteLength".into(),
                },
                register_interface::ResultField {
                    name: "dec".into(),
                },
                register_interface::ResultField {
                    name: "hex".into(),
                },
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "prefix".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomIdResult {
            b64_std: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("b64Std").unwrap(),
            ),
            b64_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("b64Url").unwrap(),
            ),
            byte_length: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("byteLength").unwrap(),
            ),
            dec: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dec").unwrap(),
            ),
            hex: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hex").unwrap(),
            ),
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            prefix: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prefix").unwrap(),
            ),
        }
    }
}
pub mod random_integer {
    //! The resource `random.RandomInteger` generates random values from a given range, described by the `min` and `max` attributes of a given resource.
    //!
    //! This resource can be used in conjunction with resources that have the `create_before_destroy` lifecycle flag set, to avoid conflicts with unique names during the brief period where both the old and new resources exist concurrently.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   # The following example shows how to generate a random priority
    //!   # between 1 and 50000 for a aws_alb_listener_rule resource:
    //!   priority:
    //!     type: random:RandomInteger
    //!     properties:
    //!       min: 1
    //!       max: 50000
    //!       keepers:
    //!         listener_arn: ${var.listener_arn}
    //!   main:
    //!     type: aws:alb:ListenerRule
    //!     properties:
    //!       listenerArn: ${priority.keepers.listenerArn}
    //!       priority: ${priority.result}
    //!       actions:
    //!         - type: forward
    //!           targetGroupArn: ${var.target_group_arn}
    //! ```
    //!
    //! ## Import
    //!
    //! Random integers can be imported using the result, min, and max, with an optional seed. This can be used to replace a config value with a value interpolated from the random provider without experiencing diffs. Example (values are separated by a ,)
    //!
    //! ```sh
    //!  $ pulumi import random:index/randomInteger:RandomInteger priority 15390,1,50000
    //! ```
    //!
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomIntegerArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The maximum inclusive value of the range.
        #[builder(into)]
        pub max: pulumi_wasm_rust::Output<i32>,
        /// The minimum inclusive value of the range.
        #[builder(into)]
        pub min: pulumi_wasm_rust::Output<i32>,
        /// A custom seed to always produce the same value.
        #[builder(into, default)]
        pub seed: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct RandomIntegerResult {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The maximum inclusive value of the range.
        pub max: pulumi_wasm_rust::Output<i32>,
        /// The minimum inclusive value of the range.
        pub min: pulumi_wasm_rust::Output<i32>,
        /// The random integer result.
        pub result: pulumi_wasm_rust::Output<i32>,
        /// A custom seed to always produce the same value.
        pub seed: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomIntegerArgs) -> RandomIntegerResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let max_binding = args.max.get_inner();
        let min_binding = args.min.get_inner();
        let seed_binding = args.seed.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomInteger:RandomInteger".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "max".into(),
                    value: &max_binding,
                },
                register_interface::ObjectField {
                    name: "min".into(),
                    value: &min_binding,
                },
                register_interface::ObjectField {
                    name: "seed".into(),
                    value: &seed_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "max".into(),
                },
                register_interface::ResultField {
                    name: "min".into(),
                },
                register_interface::ResultField {
                    name: "result".into(),
                },
                register_interface::ResultField {
                    name: "seed".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomIntegerResult {
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            max: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("max").unwrap(),
            ),
            min: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("min").unwrap(),
            ),
            result: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("result").unwrap(),
            ),
            seed: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("seed").unwrap(),
            ),
        }
    }
}
pub mod random_password {
    //! Identical to random_string.
    //!
    //! This resource *does* use a cryptographic random number generator.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   password:
    //!     type: random:RandomPassword
    //!     properties:
    //!       length: 16
    //!       special: true
    //!       overrideSpecial: '!#$%&*()-_=+[]{}<>:?'
    //!   example:
    //!     type: aws:rds:Instance
    //!     properties:
    //!       instanceClass: db.t3.micro
    //!       allocatedStorage: 64
    //!       engine: mysql
    //!       username: someone
    //!       password: ${password.result}
    //! ```
    //!
    //! ## Import
    //!
    //! You can import external passwords into your Pulumi programs as follows:
    //!
    //! ```sh
    //!  $ import random:index/randomPassword:RandomPassword newPassword supersecret
    //! ```
    //!
    //! This command will encode the `supersecret` token in Pulumi state and generate a code suggestion to include a new RandomPassword resource in your Pulumi program. Include the suggested code and do a `pulumi up`. Your secret password is now securely stored in Pulumi, and you can reference it in your Pulumi program as `newPassword.result`.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomPasswordArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length of the string desired. The minimum value for length is 1 and, length must also be >= (`min_upper` + `min_lower` + `min_numeric` + `min_special`).
        #[builder(into)]
        pub length: pulumi_wasm_rust::Output<i32>,
        /// Include lowercase alphabet characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub lower: pulumi_wasm_rust::Output<Option<bool>>,
        /// Minimum number of lowercase alphabet characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_lower: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of numeric characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_numeric: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of special characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_special: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of uppercase alphabet characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_upper: pulumi_wasm_rust::Output<Option<i32>>,
        /// Include numeric characters in the result. Default value is `true`. **NOTE**: This is deprecated, use `numeric` instead.
        #[builder(into, default)]
        pub number: pulumi_wasm_rust::Output<Option<bool>>,
        /// Include numeric characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub numeric: pulumi_wasm_rust::Output<Option<bool>>,
        /// Supply your own list of special characters to use for string generation.  This overrides the default character list in the special argument.  The `special` argument must still be set to true for any overwritten characters to be used in generation.
        #[builder(into, default)]
        pub override_special: pulumi_wasm_rust::Output<Option<String>>,
        /// Include special characters in the result. These are `!@#$%&*()-_=+[]{}<>:?`. Default value is `true`.
        #[builder(into, default)]
        pub special: pulumi_wasm_rust::Output<Option<bool>>,
        /// Include uppercase alphabet characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub upper: pulumi_wasm_rust::Output<Option<bool>>,
    }
    #[allow(dead_code)]
    pub struct RandomPasswordResult {
        /// A bcrypt hash of the generated random string. **NOTE**: If the generated random string is greater than 72 bytes in length, `bcrypt_hash` will contain a hash of the first 72 bytes.
        pub bcrypt_hash: pulumi_wasm_rust::Output<String>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length of the string desired. The minimum value for length is 1 and, length must also be >= (`min_upper` + `min_lower` + `min_numeric` + `min_special`).
        pub length: pulumi_wasm_rust::Output<i32>,
        /// Include lowercase alphabet characters in the result. Default value is `true`.
        pub lower: pulumi_wasm_rust::Output<bool>,
        /// Minimum number of lowercase alphabet characters in the result. Default value is `0`.
        pub min_lower: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of numeric characters in the result. Default value is `0`.
        pub min_numeric: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of special characters in the result. Default value is `0`.
        pub min_special: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of uppercase alphabet characters in the result. Default value is `0`.
        pub min_upper: pulumi_wasm_rust::Output<i32>,
        /// Include numeric characters in the result. Default value is `true`. **NOTE**: This is deprecated, use `numeric` instead.
        pub number: pulumi_wasm_rust::Output<bool>,
        /// Include numeric characters in the result. Default value is `true`.
        pub numeric: pulumi_wasm_rust::Output<bool>,
        /// Supply your own list of special characters to use for string generation.  This overrides the default character list in the special argument.  The `special` argument must still be set to true for any overwritten characters to be used in generation.
        pub override_special: pulumi_wasm_rust::Output<Option<String>>,
        /// The generated random string.
        pub result: pulumi_wasm_rust::Output<String>,
        /// Include special characters in the result. These are `!@#$%&*()-_=+[]{}<>:?`. Default value is `true`.
        pub special: pulumi_wasm_rust::Output<bool>,
        /// Include uppercase alphabet characters in the result. Default value is `true`.
        pub upper: pulumi_wasm_rust::Output<bool>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomPasswordArgs) -> RandomPasswordResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let length_binding = args.length.get_inner();
        let lower_binding = args.lower.get_inner();
        let min_lower_binding = args.min_lower.get_inner();
        let min_numeric_binding = args.min_numeric.get_inner();
        let min_special_binding = args.min_special.get_inner();
        let min_upper_binding = args.min_upper.get_inner();
        let number_binding = args.number.get_inner();
        let numeric_binding = args.numeric.get_inner();
        let override_special_binding = args.override_special.get_inner();
        let special_binding = args.special.get_inner();
        let upper_binding = args.upper.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomPassword:RandomPassword".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "length".into(),
                    value: &length_binding,
                },
                register_interface::ObjectField {
                    name: "lower".into(),
                    value: &lower_binding,
                },
                register_interface::ObjectField {
                    name: "minLower".into(),
                    value: &min_lower_binding,
                },
                register_interface::ObjectField {
                    name: "minNumeric".into(),
                    value: &min_numeric_binding,
                },
                register_interface::ObjectField {
                    name: "minSpecial".into(),
                    value: &min_special_binding,
                },
                register_interface::ObjectField {
                    name: "minUpper".into(),
                    value: &min_upper_binding,
                },
                register_interface::ObjectField {
                    name: "number".into(),
                    value: &number_binding,
                },
                register_interface::ObjectField {
                    name: "numeric".into(),
                    value: &numeric_binding,
                },
                register_interface::ObjectField {
                    name: "overrideSpecial".into(),
                    value: &override_special_binding,
                },
                register_interface::ObjectField {
                    name: "special".into(),
                    value: &special_binding,
                },
                register_interface::ObjectField {
                    name: "upper".into(),
                    value: &upper_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "bcryptHash".into(),
                },
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "length".into(),
                },
                register_interface::ResultField {
                    name: "lower".into(),
                },
                register_interface::ResultField {
                    name: "minLower".into(),
                },
                register_interface::ResultField {
                    name: "minNumeric".into(),
                },
                register_interface::ResultField {
                    name: "minSpecial".into(),
                },
                register_interface::ResultField {
                    name: "minUpper".into(),
                },
                register_interface::ResultField {
                    name: "number".into(),
                },
                register_interface::ResultField {
                    name: "numeric".into(),
                },
                register_interface::ResultField {
                    name: "overrideSpecial".into(),
                },
                register_interface::ResultField {
                    name: "result".into(),
                },
                register_interface::ResultField {
                    name: "special".into(),
                },
                register_interface::ResultField {
                    name: "upper".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomPasswordResult {
            bcrypt_hash: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bcryptHash").unwrap(),
            ),
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            length: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("length").unwrap(),
            ),
            lower: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("lower").unwrap(),
            ),
            min_lower: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minLower").unwrap(),
            ),
            min_numeric: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minNumeric").unwrap(),
            ),
            min_special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minSpecial").unwrap(),
            ),
            min_upper: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minUpper").unwrap(),
            ),
            number: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("number").unwrap(),
            ),
            numeric: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("numeric").unwrap(),
            ),
            override_special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("overrideSpecial").unwrap(),
            ),
            result: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("result").unwrap(),
            ),
            special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("special").unwrap(),
            ),
            upper: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("upper").unwrap(),
            ),
        }
    }
}
pub mod random_pet {
    //! The resource `random.RandomPet` generates random pet names that are intended to be used as unique identifiers for other resources.
    //!
    //! This resource can be used in conjunction with resources that have the `create_before_destroy` lifecycle flag set, to avoid conflicts with unique names during the brief period where both the old and new resources exist concurrently.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   # The following example shows how to generate a unique pet name
    //!   # for an AWS EC2 instance that changes each time a new AMI id is
    //!   # selected.
    //!   serverRandomPet:
    //!     type: random:RandomPet
    //!     properties:
    //!       keepers:
    //!         ami_id: ${var.ami_id}
    //!   serverInstance:
    //!     type: aws:ec2:Instance
    //!     properties:
    //!       tags:
    //!         Name: web-server-${serverRandomPet.id}
    //!       # Read the AMI id "through" the random_pet resource to ensure that
    //!       #   # both will change together.
    //!       ami: ${serverRandomPet.keepers.amiId}
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomPetArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length (in words) of the pet name. Defaults to 2
        #[builder(into, default)]
        pub length: pulumi_wasm_rust::Output<Option<i32>>,
        /// A string to prefix the name with.
        #[builder(into, default)]
        pub prefix: pulumi_wasm_rust::Output<Option<String>>,
        /// The character to separate words in the pet name. Defaults to "-"
        #[builder(into, default)]
        pub separator: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct RandomPetResult {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length (in words) of the pet name. Defaults to 2
        pub length: pulumi_wasm_rust::Output<i32>,
        /// A string to prefix the name with.
        pub prefix: pulumi_wasm_rust::Output<Option<String>>,
        /// The character to separate words in the pet name. Defaults to "-"
        pub separator: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomPetArgs) -> RandomPetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let length_binding = args.length.get_inner();
        let prefix_binding = args.prefix.get_inner();
        let separator_binding = args.separator.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomPet:RandomPet".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "length".into(),
                    value: &length_binding,
                },
                register_interface::ObjectField {
                    name: "prefix".into(),
                    value: &prefix_binding,
                },
                register_interface::ObjectField {
                    name: "separator".into(),
                    value: &separator_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "length".into(),
                },
                register_interface::ResultField {
                    name: "prefix".into(),
                },
                register_interface::ResultField {
                    name: "separator".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomPetResult {
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            length: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("length").unwrap(),
            ),
            prefix: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prefix").unwrap(),
            ),
            separator: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("separator").unwrap(),
            ),
        }
    }
}
pub mod random_shuffle {
    //! The resource `random.RandomShuffle` generates a random permutation of a list of strings given as an argument.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   az:
    //!     type: random:RandomShuffle
    //!     properties:
    //!       inputs:
    //!         - us-west-1a
    //!         - us-west-1c
    //!         - us-west-1d
    //!         - us-west-1e
    //!       resultCount: 2
    //!   example:
    //!     type: aws:elb:LoadBalancer
    //!     properties:
    //!       # Place the ELB in any two of the given availability zones, selected
    //!       #   # at random.
    //!       availabilityZones: ${az.results}
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomShuffleArgs {
        /// The list of strings to shuffle.
        #[builder(into)]
        pub inputs: pulumi_wasm_rust::Output<Vec<String>>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The number of results to return. Defaults to the number of items in the `input` list. If fewer items are requested, some elements will be excluded from the result. If more items are requested, items will be repeated in the result but not more frequently than the number of items in the input list.
        #[builder(into, default)]
        pub result_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Arbitrary string with which to seed the random number generator, in order to produce less-volatile permutations of the list.
        #[builder(into, default)]
        pub seed: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct RandomShuffleResult {
        /// The list of strings to shuffle.
        pub inputs: pulumi_wasm_rust::Output<Vec<String>>,
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The number of results to return. Defaults to the number of items in the `input` list. If fewer items are requested, some elements will be excluded from the result. If more items are requested, items will be repeated in the result but not more frequently than the number of items in the input list.
        pub result_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Random permutation of the list of strings given in `input`.
        pub results: pulumi_wasm_rust::Output<Vec<String>>,
        /// Arbitrary string with which to seed the random number generator, in order to produce less-volatile permutations of the list.
        pub seed: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomShuffleArgs) -> RandomShuffleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let inputs_binding = args.inputs.get_inner();
        let keepers_binding = args.keepers.get_inner();
        let result_count_binding = args.result_count.get_inner();
        let seed_binding = args.seed.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomShuffle:RandomShuffle".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "inputs".into(),
                    value: &inputs_binding,
                },
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "resultCount".into(),
                    value: &result_count_binding,
                },
                register_interface::ObjectField {
                    name: "seed".into(),
                    value: &seed_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "inputs".into(),
                },
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "resultCount".into(),
                },
                register_interface::ResultField {
                    name: "results".into(),
                },
                register_interface::ResultField {
                    name: "seed".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomShuffleResult {
            inputs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("inputs").unwrap(),
            ),
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            result_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("resultCount").unwrap(),
            ),
            results: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("results").unwrap(),
            ),
            seed: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("seed").unwrap(),
            ),
        }
    }
}
pub mod random_string {
    //! The resource `random.RandomString` generates a random permutation of alphanumeric characters and optionally special characters.
    //!
    //! This resource *does* use a cryptographic random number generator.
    //!
    //! Historically this resource's intended usage has been ambiguous as the original example used it in a password. For backwards compatibility it will continue to exist. For unique ids please use random_id, for sensitive random values please use random_password.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let random = random_string::create(
    //!         "random",
    //!         RandomStringArgs::builder()
    //!             .length(16)
    //!             .override_special("/@Â£$")
    //!             .special(true)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! You can import external strings into your Pulumi programs as RandomString resources as follows:
    //!
    //! ```sh
    //!  $ import random:index/randomString:RandomString newString myspecialdata
    //! ```
    //!
    //! This command will encode the `myspecialdata` token in Pulumi state and generate a code suggestion to include a new RandomString resource in your Pulumi program. Include the suggested code and do a `pulumi up`. Your data is now stored in Pulumi, and you can reference it in your Pulumi program as `newString.result`.
    //!
    //! If the data needs to be stored securily as a secret, consider using the RandomPassword resource instead.
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomStringArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length of the string desired. The minimum value for length is 1 and, length must also be >= (`min_upper` + `min_lower` + `min_numeric` + `min_special`).
        #[builder(into)]
        pub length: pulumi_wasm_rust::Output<i32>,
        /// Include lowercase alphabet characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub lower: pulumi_wasm_rust::Output<Option<bool>>,
        /// Minimum number of lowercase alphabet characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_lower: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of numeric characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_numeric: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of special characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_special: pulumi_wasm_rust::Output<Option<i32>>,
        /// Minimum number of uppercase alphabet characters in the result. Default value is `0`.
        #[builder(into, default)]
        pub min_upper: pulumi_wasm_rust::Output<Option<i32>>,
        /// Include numeric characters in the result. Default value is `true`. **NOTE**: This is deprecated, use `numeric` instead.
        #[builder(into, default)]
        pub number: pulumi_wasm_rust::Output<Option<bool>>,
        /// Include numeric characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub numeric: pulumi_wasm_rust::Output<Option<bool>>,
        /// Supply your own list of special characters to use for string generation.  This overrides the default character list in the special argument.  The `special` argument must still be set to true for any overwritten characters to be used in generation.
        #[builder(into, default)]
        pub override_special: pulumi_wasm_rust::Output<Option<String>>,
        /// Include special characters in the result. These are `!@#$%&*()-_=+[]{}<>:?`. Default value is `true`.
        #[builder(into, default)]
        pub special: pulumi_wasm_rust::Output<Option<bool>>,
        /// Include uppercase alphabet characters in the result. Default value is `true`.
        #[builder(into, default)]
        pub upper: pulumi_wasm_rust::Output<Option<bool>>,
    }
    #[allow(dead_code)]
    pub struct RandomStringResult {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The length of the string desired. The minimum value for length is 1 and, length must also be >= (`min_upper` + `min_lower` + `min_numeric` + `min_special`).
        pub length: pulumi_wasm_rust::Output<i32>,
        /// Include lowercase alphabet characters in the result. Default value is `true`.
        pub lower: pulumi_wasm_rust::Output<bool>,
        /// Minimum number of lowercase alphabet characters in the result. Default value is `0`.
        pub min_lower: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of numeric characters in the result. Default value is `0`.
        pub min_numeric: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of special characters in the result. Default value is `0`.
        pub min_special: pulumi_wasm_rust::Output<i32>,
        /// Minimum number of uppercase alphabet characters in the result. Default value is `0`.
        pub min_upper: pulumi_wasm_rust::Output<i32>,
        /// Include numeric characters in the result. Default value is `true`. **NOTE**: This is deprecated, use `numeric` instead.
        pub number: pulumi_wasm_rust::Output<bool>,
        /// Include numeric characters in the result. Default value is `true`.
        pub numeric: pulumi_wasm_rust::Output<bool>,
        /// Supply your own list of special characters to use for string generation.  This overrides the default character list in the special argument.  The `special` argument must still be set to true for any overwritten characters to be used in generation.
        pub override_special: pulumi_wasm_rust::Output<Option<String>>,
        /// The generated random string.
        pub result: pulumi_wasm_rust::Output<String>,
        /// Include special characters in the result. These are `!@#$%&*()-_=+[]{}<>:?`. Default value is `true`.
        pub special: pulumi_wasm_rust::Output<bool>,
        /// Include uppercase alphabet characters in the result. Default value is `true`.
        pub upper: pulumi_wasm_rust::Output<bool>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomStringArgs) -> RandomStringResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let length_binding = args.length.get_inner();
        let lower_binding = args.lower.get_inner();
        let min_lower_binding = args.min_lower.get_inner();
        let min_numeric_binding = args.min_numeric.get_inner();
        let min_special_binding = args.min_special.get_inner();
        let min_upper_binding = args.min_upper.get_inner();
        let number_binding = args.number.get_inner();
        let numeric_binding = args.numeric.get_inner();
        let override_special_binding = args.override_special.get_inner();
        let special_binding = args.special.get_inner();
        let upper_binding = args.upper.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomString:RandomString".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
                register_interface::ObjectField {
                    name: "length".into(),
                    value: &length_binding,
                },
                register_interface::ObjectField {
                    name: "lower".into(),
                    value: &lower_binding,
                },
                register_interface::ObjectField {
                    name: "minLower".into(),
                    value: &min_lower_binding,
                },
                register_interface::ObjectField {
                    name: "minNumeric".into(),
                    value: &min_numeric_binding,
                },
                register_interface::ObjectField {
                    name: "minSpecial".into(),
                    value: &min_special_binding,
                },
                register_interface::ObjectField {
                    name: "minUpper".into(),
                    value: &min_upper_binding,
                },
                register_interface::ObjectField {
                    name: "number".into(),
                    value: &number_binding,
                },
                register_interface::ObjectField {
                    name: "numeric".into(),
                    value: &numeric_binding,
                },
                register_interface::ObjectField {
                    name: "overrideSpecial".into(),
                    value: &override_special_binding,
                },
                register_interface::ObjectField {
                    name: "special".into(),
                    value: &special_binding,
                },
                register_interface::ObjectField {
                    name: "upper".into(),
                    value: &upper_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "length".into(),
                },
                register_interface::ResultField {
                    name: "lower".into(),
                },
                register_interface::ResultField {
                    name: "minLower".into(),
                },
                register_interface::ResultField {
                    name: "minNumeric".into(),
                },
                register_interface::ResultField {
                    name: "minSpecial".into(),
                },
                register_interface::ResultField {
                    name: "minUpper".into(),
                },
                register_interface::ResultField {
                    name: "number".into(),
                },
                register_interface::ResultField {
                    name: "numeric".into(),
                },
                register_interface::ResultField {
                    name: "overrideSpecial".into(),
                },
                register_interface::ResultField {
                    name: "result".into(),
                },
                register_interface::ResultField {
                    name: "special".into(),
                },
                register_interface::ResultField {
                    name: "upper".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomStringResult {
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            length: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("length").unwrap(),
            ),
            lower: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("lower").unwrap(),
            ),
            min_lower: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minLower").unwrap(),
            ),
            min_numeric: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minNumeric").unwrap(),
            ),
            min_special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minSpecial").unwrap(),
            ),
            min_upper: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minUpper").unwrap(),
            ),
            number: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("number").unwrap(),
            ),
            numeric: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("numeric").unwrap(),
            ),
            override_special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("overrideSpecial").unwrap(),
            ),
            result: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("result").unwrap(),
            ),
            special: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("special").unwrap(),
            ),
            upper: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("upper").unwrap(),
            ),
        }
    }
}
pub mod random_uuid {
    //! The resource `random.RandomUuid` generates a random uuid string that is intended to be used as a unique identifier for other resources.
    //!
    //! This resource uses [hashicorp/go-uuid](https://github.com/hashicorp/go-uuid) to generate a UUID-formatted string for use with services needing a unique string identifier.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   testRandomUuid:
    //!     type: random:RandomUuid
    //!   testResourceGroup:
    //!     type: azure:core:ResourceGroup
    //!     properties:
    //!       location: Central US
    //! ```
    //!
    //! ## Import
    //!
    //! Random UUID's can be imported. This can be used to replace a config value with a value interpolated from the random provider without experiencing diffs.
    //!
    //! ```sh
    //!  $ pulumi import random:index/randomUuid:RandomUuid main aabbccdd-eeff-0011-2233-445566778899
    //! ```
    //!
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RandomUuidArgs {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        #[builder(into, default)]
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
    }
    #[allow(dead_code)]
    pub struct RandomUuidResult {
        /// Arbitrary map of values that, when changed, will trigger recreation of resource. See the main provider documentation for more information.
        pub keepers: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The generated uuid presented in string format.
        pub result: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RandomUuidArgs) -> RandomUuidResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let keepers_binding = args.keepers.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "random:index/randomUuid:RandomUuid".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "keepers".into(),
                    value: &keepers_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "keepers".into(),
                },
                register_interface::ResultField {
                    name: "result".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RandomUuidResult {
            keepers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keepers").unwrap(),
            ),
            result: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("result").unwrap(),
            ),
        }
    }
}
pub mod functions {}
pub mod types {}
#[doc(hidden)]
pub mod constants {}
mod bindings {
    pulumi_wasm_rust::__private::wit_bindgen::generate!(
        { inline :
        r"package component:pulumi-wasm@0.0.0-DEV;

world world-random {
    import output-interface;
}

interface output-interface {

    resource output {
        constructor(value: string);
        map: func(function-name: string) -> output;
    }
    combine: func(outputs: list<borrow<output>>) -> output;
}


interface register-interface {
    use output-interface.{output};

    record object-field {
        name: string,
        value: borrow<output>
    }

    record result-field {
        name: string
    }

    record register-resource-result-field {
        name: string,
        output: output
    }

    record register-resource-request {
        %type: string,
        name: string,
        object: list<object-field>,
        results: list<result-field>
    }

    record register-resource-result {
        fields: list<register-resource-result-field>
    }

    register: func(request: register-resource-request) -> register-resource-result;

    record resource-invoke-result-field {
        name: string,
        output: output
    }

    record resource-invoke-request {
        token: string,
        object: list<object-field>,
        results: list<result-field>
    }

    record resource-invoke-result {
        fields: list<resource-invoke-result-field>
    }

    invoke: func(request: resource-invoke-request) -> resource-invoke-result;
}",
        with : { "component:pulumi-wasm/output-interface@0.0.0-DEV" :
        pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::output_interface
        } }
    );
}
